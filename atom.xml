<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jin&#39;s Blog</title>
  
  <subtitle>蔡锦的博客</subtitle>
  <link href="https://caijin.tech/atom.xml" rel="self"/>
  
  <link href="https://caijin.tech/"/>
  <updated>2022-08-22T05:06:00.791Z</updated>
  <id>https://caijin.tech/</id>
  
  <author>
    <name>Jin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《代码整洁之道》</title>
    <link href="https://caijin.tech/2022/08/21/2022/clean-code/"/>
    <id>https://caijin.tech/2022/08/21/2022/clean-code/</id>
    <published>2022-08-21T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工作后就很久没有完整的阅读过技术类型的书，最近抽时间读完了早该阅读的《代码整洁之道》收获良多，本文简单总结。</p></blockquote><span id="more"></span><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>本书讲解整洁代码的意义，如何辨别整洁的代码，如何写好的代码等，对编码中的命名、函数、注释、类、测试等都做了总结，非常贴合日常编程中的发生的种种问题。是一本适合所有程序员<strong>认真</strong>读一读的好书。</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><blockquote><p>记录了一些阅读过程中的笔记摘录和一些碎碎念，时间关系，没有把自己的碎碎念和摘录进行拆分，如果感兴趣就请随便看看。</p></blockquote><h3 id="整洁代码的重要性"><a href="#整洁代码的重要性" class="headerlink" title="整洁代码的重要性"></a>整洁代码的重要性</h3><p>作为专业的程序员自然要需要追求好代码，也需要知道糟糕代码带来的灾难，同时知道如何将糟糕代码改成好代码。</p><h4 id="糟糕的代码毁了公司"><a href="#糟糕的代码毁了公司" class="headerlink" title="糟糕的代码毁了公司"></a><strong>糟糕的代码毁了公司</strong></h4><p>业务迅速迭代，所有程序员疯狂糊屎。短期看起来可能没什么问题，但是总有一天会发现无法继续维护。</p><h4 id="混乱的代价"><a href="#混乱的代价" class="headerlink" title="混乱的代价"></a><strong>混乱的代价</strong></h4><p>随看混乱的增加，团队生产力也持续下降，趋向于零。当生产力下降时，管理层就只有体事可做了：增加更多人手到项目中，期望提升生产力。可是新人并不熟悉系统的设计（不想维护屎山）。</p><p>最终导致重构成新的系统，新的系统又需要实现所有老系统的所有功能。而在新系统能够完全和老系统媲美之前，业务老板压根不想让新系统代替老系统（鬼知道会有多少 Bug）。</p><p>同时重构之后的新系统一定会更好吗？如果他们还是没有遵守整洁代码的规范，那么将又会是一坐新的屎山，新的轮回。</p><h4 id="读与写花费时间的比例超过-10-1"><a href="#读与写花费时间的比例超过-10-1" class="headerlink" title="读与写花费时间的比例超过 10:1"></a><strong>读与写花费时间的比例超过 10:1</strong></h4><p><strong>当在写新代码时，我们一直在读旧代码！</strong></p><p>读代码是 Coding 时，最常发生的事情，尤其是维护他人的模块，或者自己长期没有维护的模块。</p><p>相信你一定有看了 1 个小时代码，最终只改了 1 行的经历（不管你有没有，反正我肯定有，而且不只 1 次，是很多次）。</p><p>例如我之前维护的一个比较复杂的的模块，因为初期设计的不合理，导致自己过了一段时间没有维护之后，再上手维护的阅读成本就非常高（也就是常说的自己看不懂自己写的什么东西）。</p><h4 id="稍后等于永不"><a href="#稍后等于永不" class="headerlink" title="稍后等于永不"></a><strong>稍后等于永不</strong></h4><p>重构应该在日常开发的时候持续的去做，而不是 “等有时间再说”</p><p>这句话说的真的很好，且不光是写代码，生活着很多事情都是这样的。例如准备和谁吃个饭，如果不立即开约，那么过一段时间可能就忘了。“下次一定“ 这个梗就是这么来的吧~</p><p>这点真的应该牢记。</p><h4 id="必须时时保持代码整洁"><a href="#必须时时保持代码整洁" class="headerlink" title="必须时时保持代码整洁"></a><strong>必须时时保持代码整洁</strong></h4><p>让营地比你来时更干净。</p><p>就像每次都做一点小的改造，解决所有小问题，自然整体就会变好。</p><p>如果每次签入时，代码都比签出时干净，那么代码就不会腐坏。清理并不一定要花多少功夫，也许只是改好一个变量名，拆分一个有点过长的函数，消除一点点重复代码，清理一个嵌套 if 语句。</p><blockquote><p>随时随地重构垃圾代码是我立即学会的事情并进行实践的事情，推荐大家也立即行动起来。</p><p>稍后等于永不，其实和《<strong>搞定Ⅰ 无压工作的艺术</strong>》中讲的一样，一件小事如果能立即完成，就立刻完成它，而不是稍后在做。喝完牛奶就洗杯子，吃完饭就洗碗，别让这些小事拖垮自己。</p></blockquote><br/><h3 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h3><p>在代码中取名真的是一件很困难，但同时又很重要的一件事，书中讲了几点需要重点注意的事。也可以看看这个：<a href="https://zh.javascript.info/ninja-code">忍者代码</a>，想要坑同事的话就按照这个来吧 🤣。</p><h4 id="名副其实"><a href="#名副其实" class="headerlink" title="名副其实"></a><strong>名副其实</strong></h4><p>变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在， 它做什么事，应该怎么用。</p><p>如果名称需要注释来补充，那就不算是<strong>名副其实</strong>。比如这样：</p><p><img src="/asset/img/2022/clean-code/1.png" alt="Untitled"></p><p>如果团队有 Lint 规则的话，就不要限制命名的长度了。相信我，太短的命名没有办法在很大的作用范围内描述清楚自身的意义。</p><h4 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a><strong>做有意义的区分</strong></h4><ol><li>别用什么 a1, a2 作为变量命名（当心被砍）。</li><li>不要用什么 ArrayList 作为命名，既然有 List 了，为什么还要用 Array 呢？</li></ol><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 他们有什么区别吗？</span></span><br><span class="line"><span class="title function_">getActiveAccount</span>();</span><br><span class="line"><span class="title function_">getActiveAccounts</span>();</span><br><span class="line"><span class="title function_">getActiveAccountInfo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接用这个就可以</span></span><br><span class="line"><span class="title function_">getActiveAccount</span>();</span><br></pre></td></tr></table></figure><h4 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a><strong>使用读得出来的名称</strong></h4><p>例如 <code>getAccount</code> 肯定好过 <code>getAct</code> ，还有人喜欢这么写 <code>list</code> → <code>lst</code> ？？？</p><p>也就是说别用缩写，或者说别用别人看不懂的缩写，没必要，别坑了以后的自己。况且有 IDE 的补全，所以不要怕名称太长。</p><h4 id="方法名用动词"><a href="#方法名用动词" class="headerlink" title="方法名用动词"></a><strong>方法名用动词</strong></h4><p>方法名应当是动词或动词短语，如 postPayment、deletePage 或 save。</p><h4 id="添加有意义的语境"><a href="#添加有意义的语境" class="headerlink" title="添加有意义的语境"></a><strong>添加有意义的语境</strong></h4><p>通过添加语境的方式让命名更易读懂。</p><p>当描述地址相关的变量时，可以添加前缀 <code>addrFirstName</code>、<code>addrLastName</code>、<code>addrState</code> 等，以此提供语境。至少，读者会明白这些变量是某个更大结构的一部分。当然，更好的方案是创建名为 <code>Address</code> 的类。</p><h4 id="不要添加没用的语境"><a href="#不要添加没用的语境" class="headerlink" title="不要添加没用的语境"></a><strong>不要添加没用的语境</strong></h4><p>例如要写一个商品发布（GoodsPublish）的页面，这时候给所有的名称前面都加上 GoodsPublish 就是一件很蠢的事情，例如 <code>GoodsPublishApi</code>, <code>GoodsPublishStore</code>。因为编码时 IDE 提示的备选项会多出一堆选项。</p><blockquote><p>命名是一件很重要的事情，好的命名能让代码可读性提升 100%！<br>能用命名解决的事情，就不要再加注释了。</p></blockquote><br/><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>系统由函数组成，我们应该学习如何写好每一个函数。</p><h4 id="短小"><a href="#短小" class="headerlink" title="短小"></a><strong>短小</strong></h4><p>短小的函数更利于阅读和理解。</p><p>书中指出不成超过 20 行，但我感觉太难了。只能尽量让函数尽可能的短吧。总之编码的时候要牢记函数要短小。</p><h4 id="只做一件事"><a href="#只做一件事" class="headerlink" title="只做一件事"></a><strong>只做一件事</strong></h4><p>一个函数做很多事情的时候，可读性就大大降低，测试难度也很高。</p><p>只做一件事的函数更便于理解和测试。</p><h4 id="单一权责原则"><a href="#单一权责原则" class="headerlink" title="单一权责原则"></a><strong>单一权责原则</strong></h4><p>例如在调用服务端接口的时候，以前可能会说，你给这个接口加个 type 然后根据 type 不同，做不同的事情。其实这个时候应该是让服务端再开一个接口，做单独的事情。</p><h4 id="使用描述性的名称"><a href="#使用描述性的名称" class="headerlink" title="使用描述性的名称"></a><strong>使用描述性的名称</strong></h4><p>简单的说就是，函数的名称要能看懂，能讲清楚这个函数是做什么的，同时不要太概括，例如渲染 HTML，renderDOMToPage 就比 render 强。</p><p>别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h4><ol><li>最理想的参数数量是零：过多的参数测试用例就很难写，因为把所有参数的组合搞出来就是一件痛苦的事情。一般来说参数数量越少的代码越容易理解；</li><li>标识参数：标识参数指的就是 Bool 类型的参数，使用 Bool 参数就明显代表了这个 fun 在做两种事情，所以这个时候我们应该把他们拆开！</li><li>参数对象：如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了；<ol><li>看起来像作弊，但其实并不是；</li><li>因为参数对象有着自己的定义，例如我传的是 goods 商品信息，那么它的定义就是商品信息，就是一个整体，我在使用的时候也知道 goods 是个什么东西；</li></ol></li></ol><h4 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a><strong>无副作用</strong></h4><p>也就是我们常说的纯函数，这种函数通常来说更容易理解 &amp; 不容易坑人！</p><p>谁也不想某个函数偷偷的就把我的变量给改了吧？</p><h4 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a><strong>使用异常替代返回错误码</strong></h4><p>这个说的就是多用 try catch，而不是抛出看不懂的状态码。</p><h4 id="如何写出这样的函数"><a href="#如何写出这样的函数" class="headerlink" title="如何写出这样的函数"></a><strong>如何写出这样的函数</strong></h4><p>先按照感觉写，然后不停的优化你的函数，打磨这些代码，分解函数、修改名称、消除重复。</p><p>我（作者）并不从一开始就按照规则写函数。我想没人做得到。<strong>大师级程序员把系统当作故事来讲，而不是当作程序来写。</strong></p><p>这一点很重要，先把要实现的功能写出来，再去思考如何优化函数。使用 IDE 的重构功能可以很方便的完成这件事。</p><br/><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释的恰当用法是弥补我们在用代码表达意图时遭遇的<strong>失败</strong>。</p><p>当我们无法用程序语言去描述代码意图时，我们才会使用注释进行弥补。</p><h4 id="注释不能美化糟糕的代码"><a href="#注释不能美化糟糕的代码" class="headerlink" title="注释不能美化糟糕的代码"></a>注释不能美化糟糕的代码</h4><p>带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样得多。与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那堆糟糕的代码。</p><h4 id="用代码来阐述"><a href="#用代码来阐述" class="headerlink" title="用代码来阐述"></a>用代码来阐述</h4><p>能用代码结束清楚的东西，就不要用注释了。</p><h4 id="好注释"><a href="#好注释" class="headerlink" title="好注释"></a>好注释</h4><ol><li>提供信息的注释：例如：这个函数被用在什么地方等等</li><li>对意图的解释：例如：为什么这部分代码一定要放在这个位置</li><li>警示：这串代码别乱动，因为 xxx 原因，这个在代码库里挺常见的，哈哈~</li><li>其他的还有：法律信息、TODO、API 注释</li></ol><h4 id="坏注释"><a href="#坏注释" class="headerlink" title="坏注释"></a>坏注释</h4><ol><li><p>喃喃自语的废话、多余的注释（还不如看代码，扰乱读者）</p></li><li><p>误导性的注释：通常是代码逻辑发生变更，而注释并没有一起变动</p><ol><li>这就是为什么能不用注释尽量不要用注释，代码永远是有效的，而注释不是</li></ol></li><li><p>日志式注释、归属与署名：</p><ol><li>很久以前，在模块开始处创建并维护这些记录还算有道理。那时，我们还没有源代码控制系统可用。如今，这种冗长的记录只会让模块变得凌乱不堪，应当全部删除。</li></ol></li><li><p>可怕的废话：</p> <figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 名称</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">// 年龄</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// 性别</span></span><br><span class="line">  <span class="attr">male</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>能用函数或变量名称描述时时就别用注释</p></li><li><p>注释掉的代码：没用的代码就删了吧，有 Git 帮你存呢，再说留着真的有参考意义吗？</p></li><li><p>信息过多：注释里面加了太多的废话或者无关的细节描述</p></li></ol><blockquote><p>如果你发现自己需要写注释，再想想看是否有办法翻盘，用代码来表达。每次用代码表达，你都该夸奖一下自己。每次写注释，你都该做个鬼脸，感受自己在表达能力上的失败。</p></blockquote><br/><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>格式关乎沟通，而沟通是专业开发者的头等大事。</p><h4 id="垂直格式"><a href="#垂直格式" class="headerlink" title="垂直格式"></a>垂直格式</h4><p><strong>短文件通常比长文件易于理解</strong></p><p>向报纸学习，报纸由许多篇文章组成；多数短小精悍。有些稍微长点儿。很少有占满一整页的。这样做，报纸才可用。假若一份报纸只登载一篇长故事，其中充斥毫无组织的事实、日期、名字等，没人会去读它。</p><p><strong>概念间垂直方向上的区隔和靠近</strong></p><p>用空行来分隔不同的代码思路；紧密相关的代码需要互相靠近，不要乱放，中间不要插奇奇怪怪的东西。</p><p><strong>垂直顺序</strong></p><p>被调用的函数应该放在执行调用的函数下面。这样就建立了一种自顶向下贯穿源代码模块的良好信息流。</p><h4 id="横向格式"><a href="#横向格式" class="headerlink" title="横向格式"></a>横向格式</h4><p>每行代码的字符过多时实在不便于阅读，所以尽量小一点，不超过 120 字符；字符少一点也便于我们分屏查看代码</p><h4 id="团队规则"><a href="#团队规则" class="headerlink" title="团队规则"></a>团队规则</h4><p>每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。</p><p><strong>一定要用格式化工具 &amp; 校验工具来保证代码格式</strong>，不会有人真的想让团队靠自觉性统一代码格式吧？给 CI 加上格式校验吧，务必让所有团队开发者遵守团队规则。</p><br/><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="使用异常而非返回码"><a href="#使用异常而非返回码" class="headerlink" title="使用异常而非返回码"></a>使用异常而非返回码</h4><p>使用 try catch finally 的方式来编写你的代码，而不是抛出难以看懂的错误码。</p><p>finally 保证了在发错发生后代码能够正常运行。</p><h4 id="给出异常发生的环境说明"><a href="#给出异常发生的环境说明" class="headerlink" title="给出异常发生的环境说明"></a>给出异常发生的环境说明</h4><p>简单来说就是 catch 的错误需要上报上来，事实也是如此，业务中的 catch 上报非常重要。</p><p><strong>代码中 catch 之后不做任何事的代码就是毒瘤中的毒瘤！</strong>请务必干掉这些代码。我被这种代码肯了不知道多少次。</p><p>场景复现：程序表现不符合预期 → 完全没有错误日志 → debug 半天发现被 .catch 住了，但是 catch 里面并没有任何处理</p><blockquote><p>整洁代码是可读的，但也要强固。可读与强固并不冲突。如果将错误处理隔离看待，独立于主要逻辑修就能得出强国面整洁代码。</p></blockquote><br/><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>测试很重要，保障代码<strong>可扩展、可维护、可复用</strong>。国内的现状是很难在业务代码中增加测试用例，原因我之前也分析过，如果实在没法给业务代码加上测试，<strong>请工具库请务必加上测试</strong>，为了自己！</p><h4 id="TDD-三定律"><a href="#TDD-三定律" class="headerlink" title="TDD 三定律"></a>TDD 三定律</h4><ol><li>在编写不能通过的单元测试前，不可编写生产代码</li><li>只可编写刚好无法通过的单元测试，不能编译也算不过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ol><h4 id="保持测试整洁"><a href="#保持测试整洁" class="headerlink" title="保持测试整洁"></a>保持测试整洁</h4><p><strong>测试代码和生产代码一样重要</strong></p><p>测试代码质量低会造成难以修改、阻碍开发的问题。</p><p><strong>测试带来一切好处</strong></p><p>代码可扩展、可维护、可复用。</p><p>没有测试个工具库代码，真的改不动（不敢改），因为你担忧改动会引入不可预知的缺陷。</p><p><strong>整洁的测试</strong></p><ol><li><strong>可读性</strong>：看不懂的测试用例和看不懂的代码一样恐怖；</li><li>构造-操作-检验(BUILD-OPERATE-CHECK)模式：就按照这个流程写测试用例，让读测试的人可以快速明白测试 case 的做什么；</li><li>打造了一套包装这些API的函数和工具代码：通过封装工具代码，让编写测试变得简单；</li></ol><h4 id="每个测试一个断言"><a href="#每个测试一个断言" class="headerlink" title="每个测试一个断言"></a>每个测试一个断言</h4><p>目的是让每个 case 都便于理解（有点难…）。</p><p><strong>单个测试中的断言数量应该最小化</strong></p><p>这个感觉现实一点，也好实现一点，断言尽量的少。</p><p><strong>每个测试一个概念</strong></p><p>测试多个概念会导致理解成本陡增，一个测试用例不要做多个事情，这个也是便于理解 case。</p><h4 id="F-I-R-S-T-原则"><a href="#F-I-R-S-T-原则" class="headerlink" title="F.I.R.S.T 原则"></a>F.I.R.S.T 原则</h4><ol><li><strong>快速(Fast)</strong><ol><li>测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。</li></ol></li><li><strong>独立(Independent)</strong><ol><li>测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，及以任何顺序运行测试。当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。</li></ol></li><li><strong>可重复(Repeatable)</strong><ol><li>测试应当可在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的接口。当环境条件不具备时，你也会无法运行测试。</li></ol></li><li><strong>自足验证(Self-Validating)</strong><ol><li>测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。你不应该手工对比两个不同文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。</li></ol></li><li><strong>及时(Timely)</strong><ol><li>测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ol></li></ol><br/><h3 id="味道与启发"><a href="#味道与启发" class="headerlink" title="味道与启发"></a>味道与启发</h3><p>代码什么时候让人感觉不舒服？书中列举了一些例子。</p><h4 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h4><ol><li>不恰当的信息：别传达和代码无关的多余信息，例如修改历史记录（Git 会帮你记录）</li><li>废弃的注释：尽快删除</li><li>冗余注释：看注释不如看代码</li><li>糟糕的注释：要写注释就好好写，别写看不懂、难读的注释</li><li>注释掉的代码<ul><li>污染模块、分散读者注意力</li><li>注释掉基本上就是废弃代码了，直接删除就可以，如果真的需要，看之前版本就可以</li></ul></li></ol><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ol><li>需要多步才能实现的构建<ul><li>系统应该能够使用一个命令进行构建</li></ul></li><li>需要多步才能做到的测试<ul><li>一行命令运行所有测试</li></ul></li></ol><h4 id="一般性问题"><a href="#一般性问题" class="headerlink" title="一般性问题"></a>一般性问题</h4><ol><li><p>明显的行为未被实现：指的是函数名称所描述的行为，函数并没有实现，这就导致其他程序员不再信任函数名称</p></li><li><p>不正确的边界行为：每种边界条件在我们编码的时候都需要考虑到，而不是依赖直觉，“感觉没问题” 不代表没问题</p> <figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="title function_">getA</span>();</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="title function_">getB</span>();</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅正确</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="title function_">getA</span>();</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="title function_">getB</span>();</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>忽视安全：请务必遵守各种 SOP</p></li><li><p>重复：</p><ul><li>每次看到重复代码，都代表遗漏了抽象</li><li>尽量不要复制粘贴代码，能做好抽象就做好抽象</li></ul></li><li><p>信息过多：设计良好的模块有着非常小的接口，让你能事半功倍</p></li><li><p>死代码：请务必删除废弃代码</p></li><li><p>人为耦合：不互相依赖的东西不该耦合</p></li><li><p>晦涩的意图：</p><ul><li>这点我认为很重要，代码如果为了追求简短写的晦涩难懂，不如写长一些，可读性高一些</li></ul></li><li><p>使用解释性变量：良好的命名很重要</p></li><li><p>函数名称应该表达其行为：</p><ul><li><code>getUserList</code> 这个命名代表了获取用户列表，那么除了获取用户列表不要做别的任何事情！</li></ul></li><li><p>理解算法：算法 &gt; 无数 if</p></li><li><p>遵循标准约定：遵守团队定义的代码规则</p></li><li><p>用命名常量替代魔术数</p><ul><li> 不是所有情况都需要使用常量代替</li><li> 如果魔术字很有强的自我解释能力，例如 2 圈，同时没有在多个地方进行使用，那么就可以直接使用魔术字</li></ul></li><li><p>准确：在代码中做决定时，确认自己足够准确</p></li><li><p>避免否定性条件</p><ul><li><code>if (buffer.shouldCompact())</code> 要好于 <code>if (!buffer.shouldNotCompact())</code></li></ul></li><li><p>函数只该做一件事</p></li><li><p>掩蔽时序耦合</p><ul><li>当有时许耦合时，请让后面的函数接收前面的参数，这样就可以保证他们的时许不会被破坏</li></ul></li></ol><h4 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h4><ol><li>采用描述性名称 <ul><li>不要太快（太随意）取名，认真思考应该取什么名称，确认名称具有描述性</li></ul></li><li>无歧义的名称 <ul><li>名称很像的时候就会发生混淆，所以我们取名的时候需要避免这种情况</li></ul></li><li>为较大作用范围选用较长名称 <ul><li>可以理解为，我们在简单的 for 循环里面使用 key, value 这种命名，但是作用范围变大后，这种命名就不太合适了</li></ul></li><li>名称应该说明副作用，而不是悄默默的添加副作用</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工作后就很久没有完整的阅读过技术类型的书，最近抽时间读完了早该阅读的《代码整洁之道》收获良多，本文简单总结。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="阅读" scheme="https://caijin.tech/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>业务代码为什么基本没有单元测试</title>
    <link href="https://caijin.tech/2022/08/17/2022/why-business-code-without-unit-test/"/>
    <id>https://caijin.tech/2022/08/17/2022/why-business-code-without-unit-test/</id>
    <published>2022-08-17T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>根据我了解到的信息，公司内的大部分的业务代码是完全没有单测的（我在的业务也没有 =。=）。测试代码可以保障我们代码的稳定性、可维护性、复用性，除了要花点时间写 🐶。那么为什么在业务代码中通常没有测试用例呢？本文简单整理了一下我的浅显理解。</p><span id="more"></span><h2 id="为什么基本没有单测？"><a href="#为什么基本没有单测？" class="headerlink" title="为什么基本没有单测？"></a>为什么基本没有单测？</h2><h3 id="业务快速迭代，需求变更频繁"><a href="#业务快速迭代，需求变更频繁" class="headerlink" title="业务快速迭代，需求变更频繁"></a>业务快速迭代，需求变更频繁</h3><p>业务快速迭代是最主要的原因，代码的快速变更让单测用例快速失效。还有就是需求频繁变更的问题。产品今天一个想法，研发开发的过程中，产品又发现逻辑不自洽、交互变更、需求变更，大家应该都遇到过类似的问题，这导致刚刚写完的测试用例又需要变更。</p><p>同时业务迭代小步快跑的策略能把人压得喘不上气，无数的需求 + 研发排期的压缩。如果需要在紧迫的排期中（很多业务常年倒排需求，产品定个上线时间点，在这之前必须上线）再挤出时间，说实话真的太难了，这就让写单测这件事情被自动牺牲掉了。</p><h3 id="有测试同学保障进行黑盒测试"><a href="#有测试同学保障进行黑盒测试" class="headerlink" title="有测试同学保障进行黑盒测试"></a>有测试同学保障进行黑盒测试</h3><p>说实话，我感觉这一点是大家能够心安理得不写测试用例的原因。因为 ”开发 → 提测 → 测试环境回归 → 线上环境回归 → 上线“ 的流程，测试起码帮你跑了两遍业务流程，测试说没问题，那么一般来说肯定就不会有问题。</p><p>但是对于核心、复杂的业务逻辑，测试同学大概率也是无法帮你回归所有 case 点的，这需要注意。</p><h3 id="成本高，研发不愿意写"><a href="#成本高，研发不愿意写" class="headerlink" title="成本高，研发不愿意写"></a>成本高，研发不愿意写</h3><p>这个感觉也是时间原因，增加单测就代表了需要维护测试代码，然而又没有那么多时间写…</p><p>还有一点就是不是所有研发了解单测，就像我这个菜🐶，进了公司到现在，从来没见过业务代码有人写测试（业务上的工具库大概率也是不写）。</p><p>所以怎么样让研发理解单测的意义，然后接受单测，也是个问题。</p><p>或者说大家基本都不是很关心代码质量，能 CV（复制粘贴）解决的需求，就 CV 解决… 那还提什么单测了。</p><h3 id="收益无法描述"><a href="#收益无法描述" class="headerlink" title="收益无法描述"></a>收益无法描述</h3><p>测试覆盖率的还不够明显吗？我的代码可维护性提升了呀？但是，业务方会关心这些东西吗？说真的，他们大概率不会 care 这些东西，他们只会关心你的需求明天能不能上线！</p><p>我个人理解如果真的重视单测，那么应该是从上至下的推进这个东西，首先业务老板和研发老板对齐认知，我们研发大头兵才有底气去做这件事~</p><h2 id="其他方法拯救代码"><a href="#其他方法拯救代码" class="headerlink" title="其他方法拯救代码"></a><strong>其他方法拯救代码</strong></h2><blockquote><p>业务代码说全部覆盖测试实话我感觉不太现实 🐶，除非你能解决前面说的几点问题。</p></blockquote><p>现在看下来，研发写单测是一件比较难以推进的事情了，但是我们还有些别的办法曲线救国。</p><h3 id="工具库一定要写测试"><a href="#工具库一定要写测试" class="headerlink" title="工具库一定要写测试"></a>工具库一定要写测试</h3><p>工具库代码最好使用 TDD 的方式进行开发，或者其他测试方案也可以，重要的是保障测试覆盖。因为工具库写测试不是为产品负责、不是为老板负责，而是为自己负责。</p><p>测试代码可以让你后面很安心的维护代码，迭代需求。且作为工具库，别人在问你这个库靠不靠谱的时候，你就可以大声的喊出：“我这个测试覆盖率 100% 的，稳的很！”（笑 🤣</p><p>对于工具库来说，测试覆盖率真的很重要。如果没有测试代码，你的后续代码变更肯定是举步维艰，自己也会很痛苦，就不要给自己埋坑了。</p><h3 id="对核心的、稳定的、重要的业务逻辑代码写单测"><a href="#对核心的、稳定的、重要的业务逻辑代码写单测" class="headerlink" title="对核心的、稳定的、重要的业务逻辑代码写单测"></a>对核心的、稳定的、重要的业务逻辑代码写单测</h3><p>当我们的业务足够稳定，那么就可以推进对核心的、稳定的业务逻辑代码进行测试用例的编写。</p><p><strong>核心的、稳定的</strong>，这两点很重要。只要代码够重要，你就必须要写测试。例如一个 BUG 可能导致 N 个 W 的损失的核心业务，你写还是不写？如果不写，那么还敢不敢上线呢？</p><p>如果业务流程简单，那么测试同学还可以帮你兜底。但核心业务一般都堆了无数的逻辑上去，测试一般是无法回归到全量 case 的（如果你们的测试足够牛逼，持续整理全量 case，当我没说）。</p><p>这其实和前面讲的工具库一个道理，没有测试用例，就不敢动。</p><h3 id="使用测试覆盖率工具保障代码"><a href="#使用测试覆盖率工具保障代码" class="headerlink" title="使用测试覆盖率工具保障代码"></a>使用测试覆盖率工具保障代码</h3><p>我们可以使用前端测试代码覆盖率工具来解决没有测试用例的问题，<strong>当然他不会像研发自己写的测试那样靠谱。但是起码保障了一定的稳定行。</strong></p><p>前端测试覆盖率工具是指通过代码插装的方式，在测试环境注入运行上报代码。当代码被执行到后，就会进行覆盖率上报。当我们的代码在测试环境被运行到后，这部分代码就为测试通过。未运行到的代码为未覆盖测试。下图（马赛克处理，将就看看）中的红色部分就是测试未覆盖到的代码：</p><img src="/asset/img/2022/why-business-code-without-unit-test/1.jpeg" alt="img"><p>测试覆盖率工具可以帮助我们部分解决代码无测试的尴尬，虽然他也有一定的局限性，那就是运行到所有代码不代表能覆盖所有 case，这就和代码测试覆盖率 100% 一样（测试覆盖率 100% 不代表覆盖 100% 的场景）。</p><p>但是，起码它能保障我们的代码都运行到了不是吗 🤣，起码你能够知道测试告诉你我已经测完了的时候，代码到底有没有被测试过~</p><h3 id="测试环境回归"><a href="#测试环境回归" class="headerlink" title="测试环境回归"></a>测试环境回归</h3><p>在测试环境回归代码，不要直接上线，这个就不多说了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据我了解到的信息，公司内的大部分的业务代码是完全没有单测的（我在的业务也没有 =。=）。测试代码可以保障我们代码的稳定性、可维护性、复用性，除了要花点时间写 🐶。那么为什么在业务代码中通常没有测试用例呢？本文简单整理了一下我的浅显理解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="https://caijin.tech/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="思考" scheme="https://caijin.tech/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>工作 3 周年记录</title>
    <link href="https://caijin.tech/2022/07/01/2022/work-3th-anniversary/"/>
    <id>https://caijin.tech/2022/07/01/2022/work-3th-anniversary/</id>
    <published>2022-07-01T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>眨眼睛已经工作3年了，自己还是那么菜，开篇文章记录一下，虽然暂时还是什么内容都没有… 所以这篇文章是 WIP 状态 不用点进来了，没有内容 🤣</p><span id="more"></span><blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;眨眼睛已经工作3年了，自己还是那么菜，开篇文章记录一下，虽然暂时还是什么内容都没有… 所以这篇文章是 WIP 状态 不用点进来了，没有内容 🤣&lt;/p&gt;</summary>
    
    
    
    
    <category term="工作" scheme="https://caijin.tech/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>复杂表单场景解决方案”原子化表单” Part 1 - 痛点</title>
    <link href="https://caijin.tech/2022/06/09/2022/complex-form-scenario-solution-atomic-form/part-1/"/>
    <id>https://caijin.tech/2022/06/09/2022/complex-form-scenario-solution-atomic-form/part-1/</id>
    <published>2022-06-09T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>糊了两年多表单，顺便写点总结，先简单聊聊常见的表单库在复杂表单场景（例如发布商品）中的痛点。</p></blockquote><span id="more"></span><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>作为前端开发者，相信大家或多或少都使用过组件库自带的表单框架，例如 <a href="https://ant-design.antgroup.com/components/form-cn/">Ant Design</a><br>提供的 <a href="https://github.com/react-component/field-form">rc-filed-form</a>（我们在使用 antd 时使用的其实是封装后的 Form，但底层是 rc-field-form）。</p><p>Antd Form 在开发一般的表单需求时，开发体验其实还不错。例如这种：</p><p><img src="/asset/img/2022/complex-form-scenario-solution-atomic-form/part-1/img_1.png" alt="Untitled"></p><p>但是遇到复杂的表单场景时，例如这种：</p><p><img src="/asset/img/2022/complex-form-scenario-solution-atomic-form/part-1/img_2.png" alt="Untitled"></p><p>这张图是电商场景下发布商品巨型表单页面中的的一小部分（国内的电商页面是这样的，表单又多又杂，可以理解…），如图所示，我们可以看到这个表单非常复杂，首先它的数据结构很复杂，还有各种深层嵌套、表单联动、动态表单（商品规格）、自增对象（SKU）等等。</p><p>如果这个时候再继续使用 Antd Form 开发的话，开发体验就比较差了，其次是维护成本也会很高。</p><p>如果你有开发过后台复杂表单项目且用的是 Antd Form 的话，相信你应该能理解笔者讲述的痛点。</p><p>对于这种复杂表单，想降低复杂度的话，思路就是进行拆分。只要能够将表单拆解的足够细，那么复杂度就可以直线降低。</p><h2 id="尝试拆分"><a href="#尝试拆分" class="headerlink" title="尝试拆分"></a>尝试拆分</h2><p>拆表单？听起来这个思路不错，那我们尝试用 Antd Form 拆分一下试试。</p><p><img src="/asset/img/2022/complex-form-scenario-solution-atomic-form/part-1/img_3.png" alt="Untitled"></p><p>如图所示，来把这个表格中的价格输入框拆出来，移除无关业务逻辑，大概长这样：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FieldFormDemo</span> = (<span class="params">&#123;skuId&#125;: &#123; skuId: <span class="built_in">string</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = form.<span class="title function_">getFieldValue</span>([<span class="string">&quot;skuInfoObject&quot;</span>, skuId, <span class="string">&quot;price&quot;</span>]);</span><br><span class="line">  <span class="comment">// ... more action</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Field</span> <span class="attr">name</span>=<span class="string">&#123;</span> [&quot;<span class="attr">skuInfo0bject</span>&quot;, <span class="attr">skuld</span>, &quot;<span class="attr">price</span>&quot;] &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Field</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来好像没什么问题？不对不对，怎么感觉越看味道越不对呢。</p><p>不是说拆分之后，复杂度就可以直接降低么？为什么我只是修改个价格的 Input 里面的 form 会需要关心 <code>skuInfo, skuId</code> 这些外层的表单？如果没有表单联动的话，我不应该只关心 <code>price</code> 吗。</p><p>但是好像不太行，如果全局使用一个 Form 实例的话，那么内部的 Form 对于表单的处理，都需要依赖 <code>[&quot;skuInfoObject&quot;, skuId, &quot;price&quot;]</code> 这个 Field 数据。</p><p>那再优化下代码：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FieldFormDemo</span> = (<span class="params">fieldArray: <span class="built_in">string</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = form.<span class="title function_">getFieldValue</span>(fieldArray);</span><br><span class="line">  <span class="comment">// ... more action</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Field</span> <span class="attr">name</span>=<span class="string">&#123;</span> <span class="attr">fieldArray</span> &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Field</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">FieldFormDemo</span> fieldArray=&#123; [<span class="string">&quot;skuInfoObject&quot;</span>, skuId, <span class="string">&quot;price&quot;</span>] &#125;/&gt;</span><br></pre></td></tr></table></figure><p>好像行了，但感觉又没那么优雅，每个表单的拆分难道都要这么写吗？</p><p><strong>其实最大的问题，就是看起来是做了拆分，但是拆分后的表单其实和外面还是藕断丝连，非常依赖传入的 FieldArray，也就是没有完全做到解耦。</strong></p><p>拆表单说起来简单，但是除了 Field 的问题，表单的拆分需要考虑的问题非常多，例如整个发布商品<strong>页面的全量表单校验、拆分的子表单校验、表单之间的联动、数据的监听</strong>等等，都是我们需要考虑的问题。</p><p>这些问题在我们做表单拆分时，如果使用 Antd Form，那么每个问题都需要去做复杂的处理。</p><h2 id="原子化表单"><a href="#原子化表单" class="headerlink" title="原子化表单"></a>原子化表单</h2><p>那么是不是可以有一个表单解决方案，可以帮我们解决这种复杂场景的问题？其实就是标题提到的 “原子化表单”。</p><p>“原子化表单”指的是天然支持原子化的表单拆解。</p><p>我们可以把包含数百个表单的巨型表单页面拆分成一个个独立的原子表单，他们内部可以<strong>单独进行校验、订阅表单数据、更新等等，表单实例可以做的事情，它都可以做</strong>。同时这些原子化的表单还可以自由组合成一个大型表单。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简述了一般的表单库在面对巨型表单场景的无力以及由此引出的原子化表单解决方案。但因为篇幅的关系，本文暂时不对原子化表单进行深入讲解，后面会补充。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;糊了两年多表单，顺便写点总结，先简单聊聊常见的表单库在复杂表单场景（例如发布商品）中的痛点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Form" scheme="https://caijin.tech/tags/Form/"/>
    
  </entry>
  
  <entry>
    <title>字体加载的几种方案</title>
    <link href="https://caijin.tech/2022/06/08/2022/several-methods-for-loading-fonts/"/>
    <id>https://caijin.tech/2022/06/08/2022/several-methods-for-loading-fonts/</id>
    <published>2022-06-08T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>众所周知，中文字体文件都是比较大的，且还有不同的字重，如果需要加载所有字重的字体文件，那体积就更加夸张，本文简述字体加载的几种方案，以及如何选择合适的方案。</p></blockquote><span id="more"></span><h4 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h4><p>这篇文章真的拖跟的有点久，其实一个多月前就想写了，但是自己拖延症的毛病实在是 …（已经不想吐槽了，我真的好懒），好在最后还是写完了。</p><p>我知道类似的这种文章网上一搜一大把，但我还是倾向于把自己学习到的内容通过文章的方式记录下来，虽然自己好奇的东西有很多，但是如果只是简单了解的话，往往又觉得不够透彻。只有把自己的学到的记录下来，才能够帮助自己更深入的理解。</p><blockquote><p>好奇 -&gt; 了解 -&gt; 学习 -&gt; 记录 -&gt; 分享-&gt; 成长</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们可以看到，一个包含所有字重的思源黑体文件大小有 30MB，这个体积是非常夸张的。</p><img src="/asset/img/2022/several-methods-for-loading-fonts/img.png" width="300px" alt="img"><p>如果我们需要对所有字体文件做加载，那么加载时间就会过长，很影响首屏时间。所以我们可以根据业务场景来使用不同的字体加载方案。</p><h2 id="全量加载字体"><a href="#全量加载字体" class="headerlink" title="全量加载字体"></a>全量加载字体</h2><p>虽然全量加载字体的操作对首屏的性能影响比较大，但是部分场景还是很常用的，例如图文编辑器(稿定设计、Canva)。所以这部分也简单记录一下。</p><p>如果是首屏的字体加载，直接写在 CSS 里面就可以了，例如这样：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: FONT_FAMILY_NAME;</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;字体 CDN 地址&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: FONT_FAMILY_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果非首屏，且是通过用户交互触发的字体加载，例如：</p><img src="/asset/img/2022/several-methods-for-loading-fonts/img_1.png" width="500px" alt="img_1"><p>这种场景则可以使用 <a href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a> 来帮助我们监听字体加载的状态态，让我们可以方便地获取字体加载成功、失败等状态，来做其他处理。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> font = <span class="keyword">new</span> <span class="title class_">FontFaceObserver</span>(<span class="string">&#x27;My Family&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">weight</span>: <span class="number">400</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">font.<span class="title function_">load</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Font is available&#x27;</span>);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Font is not available&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="部分加载字体"><a href="#部分加载字体" class="headerlink" title="部分加载字体"></a>部分加载字体</h2><p>全量加载的体验不是很好，所以我们需要提供一个方案来加载部分字体，下面列举部分加载的几种方法。</p><h3 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h3><p>最简单最暴力的方案就是直接把设计师给的图片丢到页面上去，又快又方便。当然缺点也很明显：</p><ol><li>不能再对文案进行修改</li><li>不能对文本设置样式</li><li>如果使用的是矢量图就会导致图片放大后失真(例如 1x 图在高分屏上就模糊了)，当然你可以使用 svg 解决这个问题，如果用 figma 出图的话可以直接选择导出 svg 图片</li></ol><p>如果这的时间紧迫，用这个方案也不是不可以，例如要做个简单的官网项目，时间又非常紧迫，直接在 Figma / Sketch 上导出 svg 图片就可以开心的糊页面了，又快又简单。</p><h3 id="字体裁切"><a href="#字体裁切" class="headerlink" title="字体裁切"></a>字体裁切</h3><p>使用 <a href="http://ecomfe.github.io/fontmin/#usage">Fontmin</a> 对使用到的文案进行选取，这样打包出来的字体文件就只会包含你选中的文案。</p><p>当你的文案相对固定时，就可以使用这个方案。例如之前我做的需求，设计只想用某个字体中的数字，这时我就可以直接把字体中的数字裁切出来，只需要加载几 kb 的字体。</p><img src="/asset/img/2022/several-methods-for-loading-fonts/img_2.png" width="600px"><img src="/asset/img/2022/several-methods-for-loading-fonts/img_3.png" width="400px"><h3 id="动态加载字体-⭐️"><a href="#动态加载字体-⭐️" class="headerlink" title="动态加载字体 ⭐️"></a>动态加载字体 ⭐️</h3><p>终极方案，按需加载字体，根据页面中的使用到的字体动态的加载字体文件。优点是<strong>不再限制固定文案，纵使页面的文案不断变更，也不影响字体展示</strong>。</p><img src="/asset/img/2022/several-methods-for-loading-fonts/font-load_1654579848120_0.gif" width="400px" ><p>我们可以使用 <a href="https://fonts.google.com/noto/specimen/Noto+Serif+SC?subset=chinese-simplified">Google Fonts</a> 提供的字体动态加载。 </p><img src="/asset/img/2022/several-methods-for-loading-fonts/img_5.png" width="400px" ><p>如图所示，当我们需要使用动态加载服务时，直接复制示例代码到项目中就可以了，真的非常简单。效果如下：</p><img src="/asset/img/2022/several-methods-for-loading-fonts/google-fonts.gif" width="700px" ><p>简单是简单，但是因为墙的问题，所以 Google Fonts 提供的字体在国内是无法使用的 😅。</p><p>这时我们可以也可以尝试自己来部署这套加载服务，先看看动态加载的原理吧。</p><h4 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h4><p>分析一下动态原理，涉及的主要知识点就是 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range">unicode-range</a>，它的用途可以看一下这篇文章 <a href="https://www.zhangxinxu.com/wordpress/2016/11/css-unicode-range-character-font-face/">CSS unicode-range特定字符使用font-face自定义字体</a>。</p><p>简单来说 <code>unicode-range</code> 设置了 <code>@font-face</code> 定义的字体中要使用的特定字符范围，如果页面在此范围内未使用任何字符，则不会下载字体；如果使用至少一种，则将下载整个字体。</p><p>让我们打开 Google Fonts 提供的 <a href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100&display=swap">字体使用地址</a> 看看里面都是什么：</p><img src="/asset/img/2022/several-methods-for-loading-fonts/img_6.png" alt="img"><p>里面定义了无数的 <code>unicode-range</code>，相信你已经能够看出来了：<strong>Google Fonts 将一个字体拆分成了上百个字体文件</strong>（截图只展示了部分，其实还有很多，点开链接就知道了）。</p><p>当我们页面动态输入字体时，<code>unicode-range</code> 会判断字体是否命中，当命中切片字体范围时，就会加载这部分字体文件。</p><p><strong>那么怎么把一整个大的字体文件拆成若干个小的字体文件呢？</strong></p><p>我们可以通过 <a href="https://github.com/kekee000/fonteditor-core">fonteditor-core</a> 这个库来处理字体文件，将其根据 <code>unicode-range</code> 切片，具体使用方案请参考文档，感兴趣的朋友可以深入研究。</p><p>当然，如果你需要自己部署字体动态加载的服务，还有很多因素需要考虑，例如缓存、切片力度等等等。但是因为我自己也没搞过，只是去了解和分析动态加载的原理，所以我就不在这瞎吹了，有需要实现的朋友可以自己去研究 🤣。</p><p>如果我有时间实现一个的话，我会再写文章详细讲一讲的~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简述了字体加载的几种方案以及部分原理，笔者也在持续学习中，如有错误，欢迎指正。</p><p>如果已经有动态加载的服务了，推荐直接使用动态加载字体的服务，体验应该是最好的。如果实在没加载的服务 + 固定文本，那也可以选择用 Fontmin 字体拆分。全量加载除了在特殊场景下，能不用就别用了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhangxinxu.com/wordpress/2016/11/css-unicode-range-character-font-face/">CSS unicode-range特定字符使用font-face自定义字体</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;众所周知，中文字体文件都是比较大的，且还有不同的字重，如果需要加载所有字重的字体文件，那体积就更加夸张，本文简述字体加载的几种方案，以及如何选择合适的方案。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Font" scheme="https://caijin.tech/tags/Font/"/>
    
  </entry>
  
  <entry>
    <title>实践 Monorepo 模式两年多的一些总结</title>
    <link href="https://caijin.tech/2022/05/18/2022/monorepo/"/>
    <id>https://caijin.tech/2022/05/18/2022/monorepo/</id>
    <published>2022-05-18T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>团队从 19 年末开始从 multirepo 的模式迁移到 monorepo，经历了 2 年多的历程，也有许多感悟。本文主要总结一下自己对 monorepo 这种项目管理模式的粗浅理解。</p></blockquote><span id="more"></span><p>本文不会对 monorepo 的概念进行介绍，如果你还不了解 monorepo 的概念，可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/77577415">Monorepo 是什么，为什么大家都在用？</a> 或者其他对于 monorepo 的介绍文章，网上有很多，一搜一大把。</p><h2 id="为什么使用-monorepo"><a href="#为什么使用-monorepo" class="headerlink" title="为什么使用 monorepo"></a>为什么使用 monorepo</h2><p>当初团队从 multirepo 迁移到 monorepo，主要还是因为方便共享和调试工具库，但是除了这点，monorepo 还有其他优势，比如：</p><h3 id="便捷共享和调试代码"><a href="#便捷共享和调试代码" class="headerlink" title="便捷共享和调试代码"></a>便捷共享和调试代码</h3><p>团队最初使用 multirepo 最主要的问题是多仓库共享代码、调试非常不方便，也就是开发工具库/组件库时调试很麻烦，每次都需要使用 yarn link 的模式来开发，然后开发完成后再进行发版才能供其他项目使用，这就导致了多仓库共享代码成本非常高。</p><p>切换成 monorepo 的模式后，对基础库的开发就非常省事，我们可以直接在项目中引用工具库进行开发调试，不需要再使用 yarn link。</p><h3 id="重复的基础建设"><a href="#重复的基础建设" class="headerlink" title="重复的基础建设"></a>重复的基础建设</h3><p>除了共享代码繁琐，每个工具库还需要配置自己的基础设施、CI/CD 流程、开发环境，同时每个项目都需要专人来维护，这样就很容易导致项目之间的不一致性，而后提升多项目维护成本。</p><p>试想一下，如果你需要开发多个项目，而每个项目的开发模式都是不一致的，这种体验是非常糟糕的，也是非常耗费人力成本的。</p><p>但是当我们使用 monorepo 时，我们就可以在使用一套基础建设、开发规范等来降低项目维护的成本。且只需要抽出单独的 1-2 个人力去专门维护基础建设，其他项目完全不需要再关心。</p><h3 id="简化依赖管理"><a href="#简化依赖管理" class="headerlink" title="简化依赖管理"></a>简化依赖管理</h3><p>同时因为不再使用的发包模式来管理公共代码，所以对 monorepo 内的公共依赖都是使用的最新版本，这样就很容易追踪到公共代码的变更会对其他项目的影响，当然这个时候就更需要注重公共代码的自动化测试，因为公共代码只要合并到 master 后就会立即影响所有线上项目。</p><h3 id="快速协助其他项目开发"><a href="#快速协助其他项目开发" class="headerlink" title="快速协助其他项目开发"></a>快速协助其他项目开发</h3><p>因为使用了完全相同的基础建设、工作流、开发环境，所以在团队之间相互协助的时候，不需要在配置开发环境、如何部署项目等等流程上重复浪费时间，只需要关心业务的开发即可。</p><h2 id="实践过程中遇到问题"><a href="#实践过程中遇到问题" class="headerlink" title="实践过程中遇到问题"></a>实践过程中遇到问题</h2><p>使用 monorepo 的模式的确解决了多仓库联调、基础建设复用等问题，但同时也带来了一些特有的问题。</p><h3 id="幽灵依赖（phantom-dependency）"><a href="#幽灵依赖（phantom-dependency）" class="headerlink" title="幽灵依赖（phantom dependency）"></a>幽灵依赖（phantom dependency）</h3><p>幽灵依赖指的是一个库使用了不属于其 <code>dependencies</code> 里的 package，我相信大部分使用 monorepo 的朋友应该都遇到过或者了解过。</p><h4 id="使用未声明的依赖的版本"><a href="#使用未声明的依赖的版本" class="headerlink" title="使用未声明的依赖的版本"></a>使用未声明的依赖的版本</h4><p>假设现在 <strong>APP1</strong> 依赖了 <code>A@1.0.0</code>。突然有一天，<strong>APP2</strong> 也想用 <code>A@1.0.0</code> 这个依赖，这时，在 <strong>APP2</strong> 中使用 <code>import X from &#39;A&#39;</code> 直接跑通了，看起来没什么问题，但其实 <strong>APP2</strong> 的  <code>dependencies</code> 中并没有添加 <code>A</code> 依赖，但因为有 yarn 的依赖提升，将 <code>A@1.0.0</code> 直接提升到了最外层，让 <strong>APP2</strong> 也能使用依赖项 <code>A</code>。</p><p>后来的某天 <strong>APP1</strong> 不需要依赖 <code>A</code> 了，这个时候它就把依赖项从 <code>dependencies</code> 中移除了，但是这时候，<strong>APP2</strong> 直接就挂了。</p><p>这种 case 还算是比较好的了，毕竟项目在开发或者部署的时候直接就挂了。</p><p>最惨的是，<strong>APP1</strong> 需要升级 <code>A@1.0.0</code> 到 <code>A@2.0.0</code> 升级自己的项目回归过，没问题，代码合并到 master 上线。</p><p><strong>APP2</strong> 这时候就倒霉了，<code>A@1.0.0</code> 到 <code>A@2.0.0</code> 完全不兼容，而 <strong>APP2</strong> 完全没有做相关代码的升级，这就导致线上的 <strong>APP2</strong> 项目直接就挂了。</p><h4 id="peerDependencies-错误"><a href="#peerDependencies-错误" class="headerlink" title="peerDependencies 错误"></a>peerDependencies 错误</h4><p>看一下这种场景：</p><ol><li><strong>APP1</strong> 依赖 <code>A@1.0.0</code></li><li><strong>APP2</strong> 依赖 <code>B@2.0.0</code></li><li><code>B@2.0.0</code> 将 <code>A@2.0.0</code> 作为 <code>peerDependencies</code>，故 <strong>APP2</strong> 也应该安装 <code>A@2.0.0</code></li></ol><p>但如果 <strong>APP2</strong> 没有安装 <code>A@2.0.0</code>，那么 <code>B@2.0.0</code> 则会使用被变量提升的 <code>A@1.0.0</code> 版本。</p><p>如果你运气不错， <code>A@1.0.0</code> 和 <code>A@2.0.0</code> 完全不兼容，那么项目运行就直接挂了。但如果两个版本只是有部分 API 变更，导致你开发的时候并没有遇到问题，但是一上线，直接就挂了。</p><p>或者 <strong>APP1</strong> 升级了依赖到 <code>A@3.0.0</code> 版本，也会导致 <strong>APP2</strong> 直接挂掉，因为 <strong>APP2</strong> 会使用 <strong>APP1</strong> 升级后的依赖。</p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>幽灵依赖是一个比较常见的问题，容易导致线上问题是因为比较隐蔽，很难发现，出现问题也很难定位，所以我们需要从根源上杜绝幽灵依赖的问题。</p><p>导致问题发生的罪魁祸首就是 <strong>”依赖提升“</strong>，所以我们只需要想办法解决掉它就可以了。</p><p>我们可以将包管理器换成 pnpm ，直接帮我们解决使用依赖但是不写到 <code>dependencies</code> 中的问题。</p><h3 id="编译时间-amp-依赖安装时间变长"><a href="#编译时间-amp-依赖安装时间变长" class="headerlink" title="编译时间&amp;依赖安装时间变长"></a>编译时间&amp;依赖安装时间变长</h3><p>这个问题很好理解，1 个项目和 N + 1 个项目，哪个编译/依赖安装时间更短？显而易见的是单独 1 个项目的编译时间更短。</p><p>但我们可以通过这两种方式降低构建时间（目前团队正在使用的两种方案）：</p><h4 id="按需构建减少需要构建的项目"><a href="#按需构建减少需要构建的项目" class="headerlink" title="按需构建减少需要构建的项目"></a>按需构建减少需要构建的项目</h4><p>编译时间变长主要是因为需要对所有项目进行构建，但是我们其实只需要构建变更的项目和被变更项目影响到的项目，也就是<strong>按需构建</strong>。</p><p>如果项目使用的是 lerna，那么就可以使用 <code>yarn lerna:changed</code> 找出所有需要构建的项目，然后只对这部分项目进行构建。</p><h4 id="手动指定编译项目"><a href="#手动指定编译项目" class="headerlink" title="手动指定编译项目"></a>手动指定编译项目</h4><p>当我们不需要将整个 monorepo 合并到主干分支前，我们可以只对需要构建的项目进行构建。我们可以在 commit body 中指定需要编译的项目，在 CI 脚本中对 commit body 进行识别，从而只进行单个项目的构建。</p><p>当需要合并的主干分支时，再对整个项目进行构建，只有所以项目都完成 CI 构建 &amp; 校验，才能被合并到主干分支。</p><h4 id="依赖安装加速"><a href="#依赖安装加速" class="headerlink" title="依赖安装加速"></a>依赖安装加速</h4><p>同样，项目变多了之后，依赖项就会非常多，导致安装依赖的时间非常长。</p><p>这个解决起来也很容易，如果你使用的是 pnpm 就可以使用 <strong>按需安装</strong>，也就是使用 <code>pnpm install --filter=&quot;XXX&quot;</code> 的方式来进行按需安装，相关文档：<a href="https://pnpm.io/filtering">Filtering</a>。</p><p>除了按需安装，还可以通过缓存方案来加速，可以看这篇文章：<a href="/2022/04/11/2022/cache-nodemodules-speed-ci-build/">依赖缓存加速 CI 构建</a></p><h3 id="Git-记录混乱"><a href="#Git-记录混乱" class="headerlink" title="Git 记录混乱"></a>Git 记录混乱</h3><p>因为所有人的 commit 在 monorepo 里都在一个线性历史里面，所以很乱。如果团队内没有对 commit 信息进行规范强制校验的话，就会导致项目的 commit 信息直接废弃。想解决这个问题就需要团队定义好 commit 规则，加上 Git Hooks 做好前置校验即可。</p><p>不过即使做了规范化的处理，也顶不住异常多的 commit 记录，所以建议使用可视化工具去看 Git 记录。例如笔者使用的就是 IDE 自带的 Git 工具。</p><h3 id="项目隐私性和安全性的问题"><a href="#项目隐私性和安全性的问题" class="headerlink" title="项目隐私性和安全性的问题"></a>项目隐私性和安全性的问题</h3><p>如果 monorepo 采用单个仓库，那么所有项目的代码对该仓库的所有开发者都是可见的，如果希望对某一个项目施加细粒度的权限控制，采用单仓库是很难实现的。所以如果你的项目需要做保密处理，那么就需要谨慎选择使用 monorepo（当然如果你有别的解决方案也可以告诉我）。</p><h3 id="IDE-卡顿"><a href="#IDE-卡顿" class="headerlink" title="IDE 卡顿"></a>IDE 卡顿</h3><p>实话实说，使用 monorepo 之后，我的电脑只有四个字：“芜湖起飞”，因为我习惯使用 WebStorm / IDEA 来开发项目，众所周知 JetBrains 家的 IDE 是真的吃性能，而我们的代码仓库又实在太大了，约几十个项目，且每个项目的代码量都不小。</p><p>如果你也使用的是 IDEA 可以通过 exclude 不需要关注的项目来减缓这个问题，或者只打开自己需要开发的项目。想要彻底解决这个问题的话，建议直接换成 M1 的 Mac。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你还没有使用 monorepo 这种项目管理模式，且可以接受这些痛点的话，非常推荐你进行尝试。尤其是你开发工具库的时候，monorepo 的模式实在是太香了。</p><p>如果你想实践的话最简单的方式是直接使用 <code>yarn workspace</code> 去尝试，毕竟 lerna 已经停止维护了。可以参考 <a href="https://github.com/vuejs/core">Vue 3</a> 的实践方式，照抄一下~</p><p>以上总结都是个人的一些浅显理解，希望读者朋友能从笔者的总结有所收获。如果你有不同的理解或者建议欢迎在评论区留言指出，非常感谢。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;团队从 19 年末开始从 multirepo 的模式迁移到 monorepo，经历了 2 年多的历程，也有许多感悟。本文主要总结一下自己对 monorepo 这种项目管理模式的粗浅理解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="monorepo" scheme="https://caijin.tech/tags/monorepo/"/>
    
  </entry>
  
  <entry>
    <title>Web 性能指标定义和获取方法</title>
    <link href="https://caijin.tech/2022/04/20/2022/performance-optimization-metrics/"/>
    <id>https://caijin.tech/2022/04/20/2022/performance-optimization-metrics/</id>
    <published>2022-04-20T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>如果要做前端页面的性能优化，那么肯定需要一些衡量指标来衡量优化收益。目前业界常用的衡量指标有：FP、FCP、LCP、TTFB 等等，本文简单解释一下这些指标以及如何获取方法。</p><span id="more"></span><blockquote><p>4.21 未完待续…由于本人性能优化实践还在进行中，后续会持续补充内容 &amp; 个人理解。</p></blockquote><blockquote><p> 本文仅仅是我个人的学习和整理，大多数内容来自于 <code>https://web.dev</code>，有部分总结如有错误请大家及时指出；<br> 本文不会提及如何对各指标进行优化，优化实践方案后续会单独更一篇文章；</p></blockquote><h2 id="First-Paint-FP-首次绘制"><a href="#First-Paint-FP-首次绘制" class="headerlink" title="First Paint (FP) 首次绘制"></a>First Paint (FP) 首次绘制</h2><h3 id="指标定义"><a href="#指标定义" class="headerlink" title="指标定义"></a>指标定义</h3><p>FP 指页面导航与浏览器将该网页的<strong>第一个像素渲染到屏幕上所用的中间时</strong>，渲染是任何与输入网页导航前的屏幕上的内容不同的内容。</p><p>在性能统计指标中，从用户开始访问 Web 页面的时间点到 FP 的时间点这段时间可以被视为<strong>白屏时间</strong>，也就是说在用户访问 Web 网页的过程中，FP 时间点之前，用户看到的都是没有任何内容的白色屏幕，用户在这个阶段感知不到任何有效的工作在进行。</p><p>如果我们的白屏时间过长，那么用户的流失率就会升高。</p><p>我们可以通过 Performance 面板查看到页面的 FP：</p><img src="/asset/img/2022/performance-optimizing-metrics/1.png" width="400"><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>在 MDN 上可以查到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformancePaintTiming">PerformancePaintTiming API</a> 用来获取性能数据，我们可以通过 <code>performance.getEntriesByType(&#39;paint&#39;)</code> 的方法来获取到应用的 FP 值。</p><p><img src="/asset/img/2022/performance-optimizing-metrics/2.png"></p><blockquote><p>注意：这个指标是有兼容性问题的，如果用户的游览器不支持此 API，则在埋点上报处给这部分的用户做好标识即可。</p></blockquote><h2 id="First-Contentful-Paint-FCP-首次内容绘制"><a href="#First-Contentful-Paint-FCP-首次内容绘制" class="headerlink" title="First Contentful Paint (FCP) 首次内容绘制"></a>First Contentful Paint (FCP) 首次内容绘制</h2><h3 id="指标定义-1"><a href="#指标定义-1" class="headerlink" title="指标定义"></a>指标定义</h3><p>首次内容绘制 (FCP) 指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，<a href="https://web.dev/lcp/#yuan">“内容” 指的是文本、图像（包括背景图像）、svg 元素或非白色的 canvas 元素</a>。 相比 FP，我认为 FCP 对网站的重要性更为重要，因为 FP 时用户还是无法看到有用的信息，只有完成 FCP 时，用户才能看到网页上的部分信息。</p><p><img src="/asset/img/2022/performance-optimizing-metrics/3.png"></p><p><a href="https://web.dev/fcp/#fcp-2">W3C 团队指出</a>：<strong>为了提供良好的用户体验，网站应该努力将首次内容绘制控制在 1.8 秒或以内。</strong>如果网站的 FCP &gt; 3 秒，那么体验就非常糟糕了。</p><img src="/asset/img/2022/performance-optimizing-metrics/img.png"  width="500"><h3 id="获取方法-1"><a href="#获取方法-1" class="headerlink" title="获取方法"></a>获取方法</h3><p>和 FP 相同，直接通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformancePaintTiming">PerformancePaintTiming API</a> 就能获取到 FCP 的值。</p><p><img src="/asset/img/2022/performance-optimizing-metrics/img_1.png"></p><h2 id="Largest-Contentful-Paint-LCP-最大内容绘制"><a href="#Largest-Contentful-Paint-LCP-最大内容绘制" class="headerlink" title="Largest Contentful Paint (LCP) 最大内容绘制"></a>Largest Contentful Paint (LCP) 最大内容绘制</h2><h3 id="指标定义-2"><a href="#指标定义-2" class="headerlink" title="指标定义"></a>指标定义</h3><p>LCP 是测量感知加载速度的一个以用户为中心的重要指标，因为该项指标会在页面的主要内容基本加载完成时，在页面加载时间轴中标记出相应的点，迅捷的 LCP 有助于让用户确信页面是有效的。</p><p>最大内容绘制 (LCP) 指标会根据页面首次开始加载的时间点来报告可视区域内可见的最大图像或文本块完成渲染的相对时间。</p><p><img src="/asset/img/2022/performance-optimizing-metrics/img_2.png"></p><p>如果你对细节感兴趣，想知道 W3C 团队是如何定义 LCP 的，可以查看这里：<a href="https://web.dev/lcp/#yuan-2">何时报告最大内容绘制？</a></p><p>W3C 团队同样也给出了推荐的 LCP 时间：</p><img src="/asset/img/2022/performance-optimizing-metrics/img_3.png" width="500"><h3 id="获取方法-2"><a href="#获取方法-2" class="headerlink" title="获取方法"></a>获取方法</h3><p>可以直接参考这个：<a href="https://github.com/GoogleChrome/web-vitals/blob/main/src/getLCP.ts">getLCP</a>，我这就不贴代码了。</p><blockquote><p>注意：浏览器需要支持 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Largest_Contentful_Paint_API">Largest Contentful Paint API</a> 和 PerformanceObserver API。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果要做前端页面的性能优化，那么肯定需要一些衡量指标来衡量优化收益。目前业界常用的衡量指标有：FP、FCP、LCP、TTFB 等等，本文简单解释一下这些指标以及如何获取方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="性能优化" scheme="https://caijin.tech/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>通过依赖缓存的方式实现秒级依赖安装加速 CI 构建</title>
    <link href="https://caijin.tech/2022/04/11/2022/cache-nodemodules-speed-ci-build/"/>
    <id>https://caijin.tech/2022/04/11/2022/cache-nodemodules-speed-ci-build/</id>
    <published>2022-04-11T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过手动缓存 node_modules 目录来加速 CI 构建，真滴快（秒级 &lt; 10s）！</p></blockquote><span id="more"></span><p>当我们使用 CI 构建前端项目时，对于一些 NPM 依赖项非常多的项目，依赖安装时间就会特别长。如果我们使用了 monorepo 的模式，整个团队的项目都使用同一个仓库，那么依赖数量就会指数级增长。这个时候进行依赖安装时，通常会需要 10+ 分钟以上的时间，极端情况下可能会达到 30+ 分钟。</p><p>这么长的编译时间，则会带来非常多的问题，例如：</p><ol><li>想部署一下看看效果？先等编译吧您；</li><li>测试让你修 bug，你说改好了，但是要等几十分钟编译；</li><li>需求要上线了，但是离封板时间剩下几十分钟，结果代码合并到 master 之后，光编译就花了几十分钟，还上锤子线；</li><li>…</li></ol><h2 id="使用-yarn-缓存"><a href="#使用-yarn-缓存" class="headerlink" title="使用 yarn 缓存"></a>使用 yarn 缓存</h2><p>我们可以使用 yarn / npm 的离线模式来安装依赖，这样就可以减少网络请求。但是使用这个缓存是没法减少依赖分析的时间的，所以使用缓存后的安装时间还是比较长。</p><h2 id="使用-pnpm"><a href="#使用-pnpm" class="headerlink" title="使用 pnpm"></a>使用 pnpm</h2><p>pnpm 在机制上就比 yarn 和 npm 快很多，可以看一下相关测试：<a href="https://pnpm.io/benchmarks">https://pnpm.io/benchmarks</a></p><img src="/asset/img/2022/cache-nodemodules-speed-ci-build/time.png" alt="time" width="500"><p>虽然使用 pnpm 能减少构建时间，但是依赖项太多的时候，分析依赖还是需要不少时间，剩下的分析依赖的时间能不能也节省掉呢？答案是可以的。</p><h2 id="手动缓存-node-modules"><a href="#手动缓存-node-modules" class="headerlink" title="手动缓存 node_modules"></a>手动缓存 node_modules</h2><p>有没有一种方案可以<strong>实现 10s 内依赖安装完成</strong>？答案是有的，且我们在业务上已经稳定运行两年多了，之前一直想写文章记录一下，一直拖到现在。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一句话概括：在满足相同条件时，直接使用之前安装的 node_modules，不需要再运行 yarn install，减少依赖安装和索引需要的时间。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li>在安装依赖时，先将所有的 package.json 文件进行 hash，获得唯一标识；</li><li>在 cache 中寻找是否有对应的 hash cache，如果有，那么就直接使用此 hash cache，将此 cache 软链到我们的项目中就可以完成依赖安装</li><li>如果发现没有，那么就算首次安装依赖，这次安装是比较慢的；</li><li>将安装完成后的依赖存储到 cache 中，当依赖无变更时，下次安装就可以直接使用 cache；</li></ol><img src="/asset/img/2022/cache-nodemodules-speed-ci-build/流程图.jpg" width="500px" alt="流程图"><p>给出的思路是最简单的版本，如果你的项目是 monorepo 则还需要考虑多个 package.json 和每个子项目中的 node_modules，如果项目严格使用 lock 文件的话，其实也可以使用 lock 文件来生成 cache hash 值。</p><p>当然这些都是细节上的事情，解决起来都很快，主要是这种缓存的想法。实际代码我就不贴了，因为真的不难。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>勇神的鬼点子</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过手动缓存 node_modules 目录来加速 CI 构建，真滴快（秒级 &amp;lt; 10s）！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="CI/CD" scheme="https://caijin.tech/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>英语学习的 N 次失败经历</title>
    <link href="https://caijin.tech/2022/02/27/2022/my-attempt-at-learning-english/"/>
    <id>https://caijin.tech/2022/02/27/2022/my-attempt-at-learning-english/</id>
    <published>2022-02-27T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，自从我大三开始学习英语，我经历过 n 次尝试，都已失败告终，本文算是对这些失败的一些总结和记录。 </p><span id="more"></span><blockquote><p><strong>️注意：本文非学习成功后的指导性文章，只是笔者对自己的几次失败经历作记录。</strong></p></blockquote><p>程序员英语很重要，这是我刚开始学编程就被强调过无数次的事情，但是时隔 5 年，我仍然没能掌握它 😅。</p><h2 id="学生时期"><a href="#学生时期" class="headerlink" title="学生时期"></a>学生时期</h2><p>我英语从小就不好，我记得初一的时候自己的英语还可以。虽然当时对英语完全没有兴趣，但是老师的严厉还是让我掌握了非常基础的英语。但在初二的时候就完全放飞自我了，原因是换了英语老师，一个刚毕业的英语老师。新的老师对我们非常管的非常松，所以 …</p><p>读者可能好奇，为什么你英语这么差还能混个本科啊… 实不相瞒，我高考英语只有 20 几分，具体是二十几，我也记不清了。但是这对我来说问题不大，因为机智的我在高二果断转去学习画画，当一个艺术生。没错，我就是你们能想到的那种文化不好所以去学艺术混大学的人 😅。</p><p>美术有一种考试叫单招，也就是每个学校单独对学生的美术水品进行考核，只要美术考核通过 + 文化能够过省内要求线，你就能去这个学校就读。当然，每个学校的政策都不太一样，这里就不细说了。</p><p>但其实艺术的路也并不好走，同期一起学美术的能上本科的也并不多，大概一个班级 40 个人有十几个人考上了本科，在我念的高中，高三一届小 1000 人，文化能考上本科的也有这个 2 个人，所以选择艺术专业也是实属无奈之举（有的时候选择真的比努力重要）。</p><p>所以直到大三，我的英语能力还是为 0。但是自从那会开始学习编程之后，自己就努力尝试过学习英语，但每次都无法坚持下来。</p><h2 id="第-1-次尝试：背单词（2018-9）"><a href="#第-1-次尝试：背单词（2018-9）" class="headerlink" title="第 1 次尝试：背单词（2018.9）"></a>第 1 次尝试：背单词（2018.9）</h2><p>我记得最开始学习英语的方法就是背单词，什么语法不语法的，毫不关心。</p><p>当时是看了知乎上的这篇回答 <a href="https://www.zhihu.com/question/48040579/answer/154436187">有什么相见恨晚的背单词方法？</a> 之后，自己就像抓住了救命稻草一样，觉得自己的英语有救了，就开始每天背英语。</p><p>当时计划是每天背 50 个，众所周知，我的记性非常不好，所以初期每天大概会花 2 小时的时候背，到 3 个月后，因为还需要复习之前的单词，每天的背诵时间要达到 3,4 个小时（大概）。从 18 年 9 月到年底 3 个月的时间，我断断续续背了大概 3000 个单词。可以看这篇 <a href="/2019/01/01/archived/2019-01-01-%E6%88%91%E7%9A%842018/#%E8%83%8C%E4%BA%86-2600-%E4%B8%AA%E5%8D%95%E8%AF%8D">关于我的 2018</a>。</p><p>背单词有一个最大的问题，就是没有上下文，只能死记硬背，非常痛苦，后来大概又断断续续的坚持了两三个月，可能是因为我实在没有毅力坚持做这么枯燥的事情，所以最后就没有下文了。看似记住的单词也在之后一两个月迅速忘光 …，第一次略长的英语学习宣告失败。</p><h2 id="第-2-次尝试：新概念英语-2（2019-7-8-）"><a href="#第-2-次尝试：新概念英语-2（2019-7-8-）" class="headerlink" title="第 2 次尝试：新概念英语 2（2019.7?8?）"></a>第 2 次尝试：新概念英语 2（2019.7?8?）</h2><p>大概是 7 月吧，具体时间记不太清楚了。</p><p>背单词策略失败之后，就开始想别的方法。经过我又一次网上冲浪，找到了新的学习方法（也是我现在还在使用的方法），也就是通过新概念英语来学习。</p><p>当时找到了 <strong>田静・ 新概念英语 2</strong> 的学习视频，看了下导学，我还记得导学视频上讲的：”0 基础没关系，跟着我学就能让你掌握英语。” 感觉又找到了救命稻草，于是就开始了我的第 2 次尝试，也就是跟着视频学习语法，然后背课文熟悉单词 &amp; 语法的方式来学习。为了学这个，还特意买了个 ipad pro ..hhhh。</p><p>导学里面说的的确没有骗人，跟着学就可以渐进式的学习，非常舒服。这一次算是把之前了解的各种语法知识搞明白了。</p><p>当时的学习方式其实和现在差不多，早上 7 点开始，然后学 2 ~ 3 个小时。流程是先复习之前背的课文（艾宾浩斯学习法），然后开始学习新课文。学完之后就会朗读，然后背诵，中午和晚上会再复习一遍（不过我经常会偷懒…，中午懒地背了）。</p><p>但是自己还是在坚持了大约 3 个月左右的时间放弃了。断是因为只要生活中发生一些别的事情，就会把重心放到别的事情上，然后只要一段时间没有学，那么整个人就进入了懈怠的状态，完全就不想学了。</p><p>因为只要断 2-3 天，想再开始就非常困难了，记不记得我前面说的我用的什么记忆法？艾宾浩斯学习法，对，就是这个东西。到后期我已经学习了几十篇文章之后，只要我 2-3 天没学习，那么到第 4 天如果我想学习的话，就得复习三十篇课文左右…</p><img src="/asset/img/2022/my-attempt-at-learning-english/nianlun.jpg" width="600" alt="nianlun.jpg"><p>想象一下这个 10 变成 30 …，我平常复习 10 篇慢的话也得 1 个小时（因为背的不熟的课文还需要多背诵几次，弄熟练），所以只要中间间断几天，我基本就爆炸 💥 了。</p><h2 id="第-3-次尝试：新概念英语-2-amp-重学发音（2020-9）"><a href="#第-3-次尝试：新概念英语-2-amp-重学发音（2020-9）" class="headerlink" title="第 3 次尝试：新概念英语 2 &amp; 重学发音（2020.9）"></a>第 3 次尝试：新概念英语 2 &amp; 重学发音（2020.9）</h2><p>20 年 9 月份的时候，自己来又来劲了，所以又开始学…</p><p>这一次意识到了自己的发音问题非常大，自己也不想以后在对话的时候讲 Chinglish，所以花了 1 个月的时间重新把发音部分补了一下，用的教材是谢孟媛发音，感觉还挺好的，学会了怎么使用音标。</p><p>这次学习想着上次没坚持下来可能是因为没有人监督，所以又搞了点新花样：<strong>录视频！</strong>让大家欣赏我学英语的过程，顺便监督我 … hhh 😁（我真是个鬼才 👻），想欣赏我视频的可以看这里 <a href="https://www.bilibili.com/video/BV1gT4y1c7QE">Time Lapse Day 01 3h</a>，亲自实践告诉你并不太行…</p><p>一共录了 55 期，最后嫌麻烦还是放弃了录视频了。果不其然放弃录视频之后没 1 个月，本次学习终止…</p><h2 id="第-4-次尝试：新概念英语-2（2021-3）"><a href="#第-4-次尝试：新概念英语-2（2021-3）" class="headerlink" title="第 4 次尝试：新概念英语 2（2021.3）"></a>第 4 次尝试：新概念英语 2（2021.3）</h2><p>又又开始了，我又开始作妖了，可能这就是间接性在努力吧（笑。</p><p>记得当时是被激励到了，又去翻了下自己当时的知乎动态，当时重新开始学是因为看到这两篇文章，感叹自己真是个废物，为什么还这么不努力：</p><img src="/asset/img/2022/my-attempt-at-learning-english/zhihu.jpg" width="600" alt="zhihu.jpg"><ol><li><a href="https://zhuanlan.zhihu.com/p/360390223">讲讲他的故事：从职高到MIT计算机博士录取</a></li><li><a href="https://www.zhihu.com/question/30818462/answer/207388958">真正背完新概念英语全四册是什么体验？</a></li></ol><p>不过还是间接性努力，这坚持了 81 天，你问我为什么记的这么清楚？因为我又搞了督促自己的新花样：”涂满这张表你就成功了！”。</p><p>还特意写上了鼓励的标语：”加把劲一次学完得了，间歇性努力不是浪费时间吗？” 😅😅😅 ~</p><img src="/asset/img/2022/my-attempt-at-learning-english/attempt-4.jpg" width="400" alt="attempt-4.jpg"><h2 id="第-5-次尝试：…又重新开始学-新概念英语-2（2022-1）"><a href="#第-5-次尝试：…又重新开始学-新概念英语-2（2022-1）" class="headerlink" title="第 5 次尝试：…又重新开始学 新概念英语 2（2022.1）"></a>第 5 次尝试：…又重新开始学 新概念英语 2（2022.1）</h2><p>又又又开始了，不过暂时还没有终止 …</p><p>没错，我又开始学英语了，可能还是不愿意承认自己是个 five 吧。</p><p>想学习英语的 CS 课程、想能够轻松查看英语文档、想贡献开源代码、想找国外公司 remote、想…太多了，太多理由让我重新开始再次学习英语，只希望这次不要再轻言放弃，时间不多了呀！</p><h2 id="学如逆水行舟，不进则退"><a href="#学如逆水行舟，不进则退" class="headerlink" title="学如逆水行舟，不进则退"></a>学如逆水行舟，不进则退</h2><p>几次英语的学习让我明白最重要的道理就是：<strong>学如逆水行舟，不进则退。</strong> 希望自己好好记住这个道理，不要经常放弃，把英语学习这件事情坚持下来。</p><p>学习过程中最重要地可能不是什么学习方法，而是坚持的这颗心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说来惭愧，自从我大三开始学习英语，我经历过 n 次尝试，都已失败告终，本文算是对这些失败的一些总结和记录。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="英语" scheme="https://caijin.tech/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>关于我的 2021</title>
    <link href="https://caijin.tech/2022/02/20/2022/2021-summary/"/>
    <id>https://caijin.tech/2022/02/20/2022/2021-summary/</id>
    <published>2022-02-20T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没写总结之前感觉 2021 好像就这么消失了，但其实并没有 …</p></blockquote><span id="more"></span><p>因为去年没立什么 flag、目标，所以也没有什么对于 flag 的总结，就随意写点吧。</p><h2 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h2><p>在雪季没到来之前，自己真的是非常非常非常 *n 的想滑雪（想疯了），每天晚上都会在网上狂刷（经常刷着刷着就晚上2,3点了）滑雪相关的视频，例如：</p><ol><li><a href="https://www.youtube.com/watch?v=yyt3k9Tkzx4&t=707s">Richard踩上Ryan大神的Donek板 结果很暴力 Feat. Vincent VLOG 314</a></li><li><a href="https://www.youtube.com/watch?v=CecSg3ac9qE">gray type r carving ~ 帅的飞起</a></li><li><a href="https://www.youtube.com/watch?v=Y4kwdi_GwlA">20-21 Free Riding Movie</a></li><li><a href="https://www.youtube.com/watch?v=PvukG-gsPso">rama109 平间和德</a></li></ol><p>在 8 月份的时候看了某个博主推荐夏天可以用陆地冲浪板先练习，所以 9 月份的时候就入了个陆地冲浪板练了两个多月，中间还去找教练专门学习了一下 4000 大洋，感觉不是很值。</p><p>看我冲坡 😅：</p><img src="/asset/img/2022/2021-summary-@3.png" width="500px" alt="2021-summary-@3"><p>10月30号的时候雪季开板，第一天滑激动地不行，但是雪场上的人实在是太多，雪道也只开了一条，自以为夏天练习过就会滑地很好，结果不出所料摔了个狗吃屎，直接摔出内伤，第二天的滑雪计划也直接报销了，并且腿一个雪季也没好，太惨了。</p><p>因为冬奥的原因，所以这个雪季崇礼只有不到两个月的时间能完，自己也算是基本全勤吧。每周都有去，10.30 → 12.25，一共上雪 20 天，腿摔到现在（2.20）还没有好…，还得去医院再看看，只能说注意安全。</p><p>最终滑成这样：<a href="https://www.bilibili.com/video/BV13L4y1g7WJ/">Snowboard Carving Record - 2021.12.19</a></p><p>不好也不坏吧，自己很满意了，明年继续进步。</p><h3 id="工作还是生活，WLB-什么时候能实现？"><a href="#工作还是生活，WLB-什么时候能实现？" class="headerlink" title="工作还是生活，WLB 什么时候能实现？"></a>工作还是生活，WLB 什么时候能实现？</h3><p>…TODO</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="表单解决方案的重构"><a href="#表单解决方案的重构" class="headerlink" title="表单解决方案的重构"></a>表单解决方案的重构</h3><p>表单解决方案的第一版是已经离职的大佬留下的，第一版只满足了基础的功能，在一些特殊场景上，它就没办法很好的满足。所以我就接手下来完善它。可惜自己当时的实力的确不行，慢慢的就把代码改成屎坑了。导致后续的维护成本实在太高。</p><p>所以在今年年中的时候，就开始构思怎么去重构，零零碎碎花了1个月的时间，把 2.0 第一版发上去了，自己还是比较满意，也学到很多东西，可惜这个东西一直不是老板满意的方向。所以现在投入的时间也比较少了。关于表单相关的事情后续应该（一定）会开文章详细聊一聊的。</p><p>后续会在业余时间写一个开源的版本。</p><h3 id="页面搭建"><a href="#页面搭建" class="headerlink" title="页面搭建"></a>页面搭建</h3><p>今年工作上除了表单库之外比较有意思的东西吧。团队维护的商品创建页面里面，有个商品详情编辑的功能，之前一直是富文本，但因为无法满足业务需要所以需要升级为商品详情搭建（就是商品详情装修），拖拽模块来生成页面类似这种（工作上做的东西就不截图了，和这个差不多）：</p><p><img src="/asset/img/2022/2021-summary-@1.jpg" alt="Untitled"></p><p>搞过一遍之后发现搭建挖到最基础还是比较简单的，但是叠加上复杂的业务组建之后，又可以做的非常复杂。还是非常有意思的。这里就不细说了，以后会写 blog 总结（疯狂开坑，是嫌自己之前鸽的不够久吗 hhhh）</p><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><p>想说的太多，先放着，会补充~</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>又是英语… 年初颓费了很长一段时间，然后在 3 月份又开始学英语，结果是完全不出所料，3个月，不多不少，7月份又又又停了，真的是刚刚好三个月。</p><p>抓狂，自己为什么这么垃圾啊，每次都是这样，已经 3 月份已经是第 3 次放弃了…</p><p>人都已经麻了。这件事情一定要好好复盘反思。</p><p>虽然已经放弃很多次，但是又开始重新学习了，2022.1 继续重新开始，今天 2.20 已经坚持 2 个月了，这一次 …，只能说做好自己吧，努力坚持下去。现在有每周公开的周报监督，应该能坚持实现自己的目标。</p><h2 id="知识管理"><a href="#知识管理" class="headerlink" title="知识管理"></a>知识管理</h2><p>今年很高兴能发现 Logseq 笔记软件，自己用起来的感觉就是 “双链” 笔记真的很适合学习，用了两个月构建了自己的知识网：</p><img src="/asset/img/2022/2021-summary-@5.jpg" width="600px" alt="2021-summary-@5"><p>关于 Notion 和 Logseq 的取舍或者说使用方法自己还需要再多思考一下，怎么样平衡两个笔记，目前来看 Notion 还是没法抛弃的。</p><p>还有一个就是 DEVNOThink + 简悦 组合，用来做知识存储。利用简悦存储文章到本地，再用 DEVNOThink 做文章内容检索，搭建完成之后非常方便，效果如图：</p><p><img src="/asset/img/2022/2021-summary-@4.jpg" alt="Untitled"></p><h2 id="总结-amp-2022"><a href="#总结-amp-2022" class="headerlink" title="总结 &amp; 2022"></a>总结 &amp; 2022</h2><p>今年整体上来说自己是过的非常<strong>迷茫</strong>，工作生活方方面面，都很迷茫，不知道自己应该做什么，每天都感觉自己过的很混沌，可能是因为没有什么清晰的目标 &amp; 自己想做的事情吧。</p><p>2022 需要更清晰的目标来解决这个问题。</p><h3 id="2022-Goals"><a href="#2022-Goals" class="headerlink" title="2022 Goals"></a>2022 Goals</h3><p>在这里定下的目标每周都会在 Weekly 中同步记录！</p><h4 id="⭐⭐⭐️-英语"><a href="#⭐⭐⭐️-英语" class="headerlink" title="⭐⭐⭐️ 英语"></a>⭐⭐⭐️ 英语</h4><p>英语是今年最重要的事情，没有之一，从毕业到现在每年都有在学，每年都学的不怎么样，三天打鱼，两天晒网的状态持续的真的是太久了。</p><p><strong>PLAN1: 基础</strong><br>4 月中旬前学完新概念 2，目前已经学习到 70 课了（2022/2/21），还剩下 26 课，时间上有差不多 7 周，给的时间比较宽裕，按照现在一周 5 课的进展，应该没什么问题。</p><p>4 月剩下的时间会整体复习新概念 2，然后准备开始学习新概念 3。 新概念 3 学完的时间不太确定，按照学新 2 的经验，应该会花比较长的时间。</p><p>5月开始学习新概念 3，先大概定个时间吧，4 个月内学完。<br>因为中间可能会随时改变计划，例如增加其他学习方向，例如阅读、口语、听力等等，所以时间上还不太确定。</p><p>暂定 3-6 这 4 个月的时间专注在新概念英语的学习上吧。</p><p><strong>PLAN1: 口语 &amp; 听力</strong><br>然后今年肯定会报的是口语训练课程，也就是找人说英语，毕竟哑巴英语不是我学习的目标。</p><p>在新 3 学习的过程中，或者是学习完成后，总之就是感觉差不多可以了的时候，会开始口语 &amp; 听力的练习。</p><p>听力练习材料选择的是之前其他博主推荐的播客：</p><ol><li>The English We Speak</li><li>6 Minute English</li></ol><p>口语练习可能会选择：</p><ol><li>公司内部的 Rosetta Stone</li><li>Cambly</li></ol><p>具体学习计划会之后再确定。</p><p><strong>其他</strong></p><p>可能有读者会好奇，一个新概念你学这么慢？我只能说天赋在这里，记性就是很差，没什么太好的办法… 我的每日学习流程也比较耗费时间（对于我的资质来说），大概是这样：</p><p>学习时间每天大概是 2 - 3 个小时，具体流程为：</p><ol><li>7:00 ~ 7:30 之间开始</li><li>复习之前背诵的内容（我是用 艾宾浩斯遗忘曲线 学习法复习背诵的课文）0.5 ~ 1 之间（看当日有几篇文章要复习）</li><li>学习新课文 30 ~ 60 min （看文章难易程度，到学 新 3 的时候学习时间肯定还会再增加）</li><li>背诵 30 ~ 60 min 之间（记性不好，背的很慢，忘的很快）</li></ol><p>总之就是非常耗时…（还是因为记性不好），有空写篇文章聊聊我是怎么学习英语的吧，虽然我的英语到现在为止并好没有学成，但我相信过一段时间之后会变好的（笑 😂</p><h4 id="O2-⭐⭐-博客"><a href="#O2-⭐⭐-博客" class="headerlink" title="O2: ⭐⭐ 博客"></a>O2: ⭐⭐ 博客</h4><p>今年打算好好写博客，不管写的内容怎么样，先写起来。</p><p><strong>Weekly 周报</strong><br>这个是从 2 月第 2 周开始的，后面也会一致持续更新。每周的公开周报可以记录记录生活，同时也是督促自己完成 flag 的一种很好的方式。</p><p><strong>其他</strong><br>其他的内容大概和 1 年前写的&lt;重新开始写博客&gt;没什么变化吧（笑 😂，这篇&lt;重新开始写博客&gt;真的是把自己钉在耻辱柱上了），可能重心发生了变化，更多的是用博客记录生活和一些规划吧。</p><ol><li>读书笔记</li><li>生活规划</li><li>一些深入研究一个技术点（有空就会研究）</li><li>工作中值得分享的内容（工作中的一些总结）</li><li>英语学习记录（在周报里做记录吧）</li></ol><h4 id="03-⭐-其他"><a href="#03-⭐-其他" class="headerlink" title="03: ⭐ 其他"></a>03: ⭐ 其他</h4><p>… TODO</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;没写总结之前感觉 2021 好像就这么消失了，但其实并没有 …&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://caijin.tech/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="总结" scheme="https://caijin.tech/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>重新开始写博客</title>
    <link href="https://caijin.tech/2021/04/13/archived/2021-04-13-%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://caijin.tech/2021/04/13/archived/2021-04-13-%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-04-13T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>毕业到现在转眼已经快两年了，也有两年多的时间没有写博客了。<span id="more"></span></p><p>一个是因为工作之后总是会给自己找各种各样的理由偷懒，而就是因为工作真的好忙…，还有就是工作之后觉得自己很菜，写出来的东西都很水，不好意思写（现在想想其实没必要）。</p><p>总之，之后会好好更博客的，暂时先争取做到月更吧。</p><p>内容大致为分为几块：</p><ol><li>每月深入研究一个技术点</li><li>工作中值得分享的内容</li><li>英语学习记录（预计每双周做一个记录）</li><li>读书笔记</li><li>生活规划</li><li>…等等</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;毕业到现在转眼已经快两年了，也有两年多的时间没有写博客了。</summary>
    
    
    
    
    <category term="生活" scheme="https://caijin.tech/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nginx 进行端口转发</title>
    <link href="https://caijin.tech/2019/03/05/archived/2019-03-05-%E4%BD%BF%E7%94%A8Nginx%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>https://caijin.tech/2019/03/05/archived/2019-03-05-%E4%BD%BF%E7%94%A8Nginx%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</id>
    <published>2019-03-05T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>当我们让域名解析指向服务器的 IP 地址时，如果想访问非 80 端口上的服务时，就需要加上 <code>:port</code>，很显然这样很丑，所以我们就可以通过使用 Nginx 来监听 80 端口，判断发起请求的 URL，然后转发到不同的端口上。<span id="more"></span></p><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p>首先我们需要给服务器安装 Nginx。</p><p>在 CentOS 7 中，直接使用 yum 安装 Nginx 会提示无下载源。因此，需要添加 Nginx 的下载源到 yum：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>指定了下载源后，就可以使用 yum 命令来安装 Nginx 了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure><p>安装完成的 Nginx 并不会立刻启动，需要我们手动执行命令来开启它:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure><p>还可以输入以下命令，让 Nginx 可以随系统自动启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><p>相关命令补充：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启 Nginx</span></span><br><span class="line">service nginx start</span><br><span class="line"><span class="comment"># 停止 Nginx</span></span><br><span class="line">service nginx stop</span><br><span class="line"><span class="comment"># 重启 Nginx</span></span><br><span class="line">service nginx restart</span><br><span class="line"><span class="comment"># 查看 Nginx 状态</span></span><br><span class="line">service nginx status</span><br></pre></td></tr></table></figure><p>Nginx 的默认站点根目录为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/share/nginx/html/</span><br></pre></td></tr></table></figure><p>默认站点配置在：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure><p>Nginx 主配置如下（当修改配置文件后需要运行 <code>service nginx restart</code> 重新启动使配置剩下，在修改前<strong>注意备份</strong>！）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>接着我们就需要来修改配置文件：</p><ol><li>首先使用 vim 打开配置文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ... 省略</span></span><br><span class="line">http &#123;</span><br><span class="line">    // 当通过 your-url-namem:80 端口访问这个服务器时</span><br><span class="line">    // 该请求会被转发到 127.0.0.1:9992</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80; </span><br><span class="line">        server_name your-url-name.com; </span><br><span class="line">        // 通过访问的路径来处理转发 ...</span><br><span class="line">        location / &#123; </span><br><span class="line">            // 也不一定是内网 127.0.0.1 ，也可以是另外一个服务器的某个端口等 ...</span><br><span class="line">            proxy_pass http://127.0.0.1:9992;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ... 省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ... 省略</span></span><br></pre></td></tr></table></figure><ol start="3"><li>保存配置文件之后</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启 Nginx 使得配置生效</span></span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>成功之后我还没高兴 1 分钟就发现了一个让人蛋疼的事情</p><img src="https://i.loli.net/2019/03/05/5c7d657b8a66d.png"><p>真的是！！！好气啊！算了算了备案去了。</p><p>参考资料：</p><ol><li><a href="http://www.nljb.net/default/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/">Nginx 反向代理之端口转发</a></li><li><a href="https://chaishiwei.com/blog/1281.html">CentOS 7 用 yum 安装 Nginx</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们让域名解析指向服务器的 IP 地址时，如果想访问非 80 端口上的服务时，就需要加上 &lt;code&gt;:port&lt;/code&gt;，很显然这样很丑，所以我们就可以通过使用 Nginx 来监听 80 端口，判断发起请求的 URL，然后转发到不同的端口上。</summary>
    
    
    
    
    <category term="后端" scheme="https://caijin.tech/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>春招结束</title>
    <link href="https://caijin.tech/2019/03/03/archived/2019-03-03-%E6%98%A5%E6%8B%9B%E7%BB%93%E6%9D%9F/"/>
    <id>https://caijin.tech/2019/03/03/archived/2019-03-03-%E6%98%A5%E6%8B%9B%E7%BB%93%E6%9D%9F/</id>
    <published>2019-03-03T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>终于拿到 offer 啦，很开心，三方也寄了，可以提前结束春招了~<span id="more"></span></p><p>因为我自身的一些原因，所以华丽的错过了秋招，所以只有把希望都寄托在春招上了。如果春招凉凉的话，那么工作可能就很难找了！所以我在很早的时候就开始准备春招了，差不多准备了有两个月吧。</p><p>大概是二月初也就是刚过完年不久，就开始想办法投简历了。那个时候各家公司的春招还没有开始，所以我就需要找大佬们帮我内推。当然，我是不认识大佬的，所以就在V站、掘金上的求职区，晒简历，希望有人能帮我内推，然后就有大佬帮我内推了，很感谢能帮我内推的大佬们。</p><p>因为时间还比较早，开始春招的公司比较少，所以就面了头条和小米（都是大佬们帮忙内推的，免了笔试很开心），然后还有两家创业公司。</p><p>头条和小米都拿到 offer 了，说实话我自己都想不到会这么顺利（顺利到不敢相信）。我觉得可能是我准备的时间比较长，还有就是我有一些拿得出手的开源项目。所以我觉得有一些不错的个人的开源项目的话，在校招的时候还是非常占优势的，首先就是简历可能比较容易过，然后面试的时候可以聊一聊自己的项目。</p><p>然后再说说我找工作前做了些什么准备，希望对正在找工作的你有帮助。面经的话我就不放了，有需要的话直接去牛客上搜就可以了。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="1-查漏补缺"><a href="#1-查漏补缺" class="headerlink" title="1. 查漏补缺"></a>1. 查漏补缺</h3><p>去牛客上找面经，把所以想去公司的面经都扒出来，然后总结成一张图，进行查漏补缺，比如像这样：</p><img src="https://i.loli.net/2019/03/03/5c7b93a3cf045.png"/><p>我这里使用的是 MindNode，你也可以用别的思维导图。然后我就开始检查自己有那些不会的题目，哪些不会就说明我对这部分的知识点还不是很清楚，就去补。</p><p>然后每天就去复习一下。我复习的方法就是假装面试官在向自己提问，然后我回答。一定要讲的非常清楚，如果模糊不清的话就去复习这个知识点。</p><p>然后除了用说的一些知识点，面试的时候还会考一些功能实现（要手写代码的），这些也一定要准备好了，比如什么实现 Promise、实现懒加载、实现防抖+懒加载、实现 bind 方法、实现简单的路由等等。</p><h3 id="2-刷题：剑指-offer-LeetCode"><a href="#2-刷题：剑指-offer-LeetCode" class="headerlink" title="2. 刷题：剑指 offer + LeetCode"></a>2. 刷题：剑指 offer + LeetCode</h3><p>如果想进大一点的公司的话，刷题肯定是跑不掉的。因为它们都会让你手写一些算法题。剑指 offer 我是在牛客上刷的，大概刷了 80% 吧（有些难得我选择放弃），刷了两遍。然后 LeetCode 大概刷了不到 100 道题目，都是简单和中等的（太难的我也不会，emmm）。</p><h3 id="3-简历"><a href="#3-简历" class="headerlink" title="3. 简历"></a>3. 简历</h3><p>简历一定要准备 PDF 版本的，同时也可以准备一个在线的简历。如果你用 doc 或者乱七八糟格式的话，谁知道在别人的电脑上打开是什么样子。PDF 的好处就是不管在哪里用什么打开都是一模一样的。</p><p>因为我之前是设计专业的，所以我的简历是 AI 做的，但是会这个软件的人在程序员里面应该是少数，所以推荐大家直接用这个大佬的写工具生成简历：<a href="https://hacknical.com/">https://hacknical.com</a> 生成的简历还是很好看的。</p><h3 id="4-找人内推"><a href="#4-找人内推" class="headerlink" title="4. 找人内推"></a>4. 找人内推</h3><p>内推！内推！内推！一定要找人内推，不然简历很容易石沉大海。</p><p>内推真的很重要，如果没有认识的人帮忙内推的话，觉得自己简历不错的话就可以把简历在社区上发出来（比如 V站、掘金、知乎等等），大佬们对于不错的简历还是很乐意帮忙的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>因为今年互联网的就业形式好像不太好，很多大厂都没有对于大四的春招，都是在招大三实习生。而且网易的毁约也传的沸沸扬扬，所以我能拿到头条和小米的 offer 我已经很开心了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于拿到 offer 啦，很开心，三方也寄了，可以提前结束春招了~</summary>
    
    
    
    
    <category term="生活" scheme="https://caijin.tech/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于我的 2018</title>
    <link href="https://caijin.tech/2019/01/01/archived/2019-01-01-%E6%88%91%E7%9A%842018/"/>
    <id>https://caijin.tech/2019/01/01/archived/2019-01-01-%E6%88%91%E7%9A%842018/</id>
    <published>2019-01-01T17:00:41.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>关于我的 2018 年度小结。<span id="more"></span></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oldChecklist = [], newChecklist = [];</span><br></pre></td></tr></table></figure><h2 id="入了前端的坑"><a href="#入了前端的坑" class="headerlink" title="入了前端的坑"></a>入了前端的坑</h2><p>因为对计算机的喜爱，以及对设计的一些无奈。所以从大二下学期开始决定入计算机的坑。</p><p>因为自己本身学了一些设计，之后又了解到了前端对于设计稿的实习，所以产生了很大的兴趣。于是开始准备学习前端。</p><p>但是之后因为自己的一些事情就耽搁了很久，所以直到18年二月左右（具体时间有点记不太清楚了）开始才静下心来用心学习前端。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;入坑前端攻城狮&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="完成一些小项目"><a href="#完成一些小项目" class="headerlink" title="完成一些小项目"></a>完成一些小项目</h2><ol><li>在学习了一段时间之后，过了一遍 HTML、CSS、JS，完成了自己的第一个小项目，一个简单的小游戏：-&gt; <a href="https://caijin.tech/blog/2018/03/22/2018-03-22-mine-sweeping">扫雷游戏</a>。虽然代码很稚嫩，但也算是自己的第一完整的项目。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;扫雷游戏&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>之后又学习了 Vue，刷文档，去慕课上面找视频看，最后实现了自己的第一个还不错的项目：<a href="https://github.com/caijinyc/vue-music-webapp">Vue 网易云音乐 WebApp</a>。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;Vue 网易云音乐&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>因为感觉学校图书馆书籍查询比较麻烦，所以在实习的时候就准备写一个图书馆查询的小程序，但拖延症的毛病又犯了，直到十一月的回家后才开始撸，结果因为域名没有备案，微信小程序的接口必须是要有备案的，所以只好写了个 Web 版的 -&gt; <a href="https://github.com/caijinyc/library-book-search">书查查 - 图书馆书籍查询小程序</a></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;书查查&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>然后是写了一个 Hexo 的主题，因为自己不是很满意，算是个半成品，所以一直没有提交到官方，最近也是快把它遗忘了。以后有时间会继续补充 -&gt; <a href="https://github.com/caijinyc/hexo-theme-osimple">hexo-theme-osimple</a>。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;Hexo 主题半成品&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>因为实习公司用的是 React ，实习结束因为好久没用有点忘了，最近拿出来复习一下，于是用 React + Electron 撸了一个 Here 音乐客户端。因为不想只是做一个很简单的项目，而是想做一个好用 + 好看的音乐客户端，所以这个项目也是付出了很多的心血，目前已经完成了 80% 了，先放两张图看看，大概长这样：</li></ol><img src="https://s2.ax1x.com/2019/01/01/F5n726.png" alt="F5n726.png" border="0" align="center"><img src="https://s2.ax1x.com/2019/01/01/F5nHxK.png" alt="F5nHxK.png" border="0" align="center"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;快写完的 Here Music&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="实习了三个月"><a href="#实习了三个月" class="headerlink" title="实习了三个月"></a>实习了三个月</h2><p>六月的时候的时候找的实习，因为当时自己对春招没有什么概念，所以无疑是错过了春招，但是庆幸还是找到了实习。</p><p>关于实习之前的文章里面已经有讲过了，可以看这里 -&gt; <a href="https://caijin.tech/blog/2018/08/12/2018-08-12-%E4%B8%83%E6%9C%88%E5%AE%9E%E4%B9%A0%E5%B0%8F%E8%AE%B0/">实习小记</a>，这个文章是实习中途写的。有一些当时对于自己实习的一些想法、感悟。</p><p>在实习结束之后还想写一下实习中遇到的问题，以及自身的各种不足（自己真的很水），但是一直拖拖拖，好像是要拖没了😅，尴尬。</p><p>总之三个月的实习收获了很多：例如 React、Git、项目流程、代码规范、团队合作、租房经验、实习经历等等等。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;实习三个月，收获颇丰&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="背了-2600-个单词"><a href="#背了-2600-个单词" class="headerlink" title="背了 2600 个单词"></a>背了 2600 个单词</h2><p>想在程序员的路上走更远，英语是跑不掉了。但是我的英语水平…，可以说是没有水平🤣。</p><p>所以从背单词开始，9月末的时候开始背，计划是每天 50 个，但是到后期实在是坚持不下去，因为需要不停的复习，到两千个单词的时候，复习加上背诵就需要 4 - 5个小时的时间（因为我对英语实在是有点记不住），实在是有点崩溃。到之后换成了每天背诵 25 个单词，但也是断断续续，所以 三个月一个背了 2700 个单词。</p><img src="https://s2.ax1x.com/2019/01/01/F515Ie.png" alt="F515Ie.png" border="0" /><p>最近在写 Here Music 的时候，很多文档是没有官方的中文翻译的，而且的码代码的过程中，很多报错都搜不到中文的解决方法，只能用抠脚英语 + 翻译慢慢看。</p><p>所以深深感受到英语差在程序员的道路上是不能走远的。所以学英语这件事，一定不能停。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChecklist.<span class="title function_">push</span>(<span class="string">&#x27;背了 2600 个单词&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h2><p>很多想做的事情，都被自己一拖再拖。</p><p>就比如背单词这件事，明明早上背完一天轻松，但是却总是躲着它，脑子里想的是，哎呀我晚上背也是可以的嘛，于是就放纵自己晚上再说，等到了晚上，巧了一天代码，一点精神气也没有的时候，就想着，算了算了，明天再说吧，简直是恶性循环中的毒瘤。</p><p>所以在新的一年中，要加强自己的执行力，而不是只有嘴上计划，而没坚持的执行。</p><h2 id="关于接下来的-2019"><a href="#关于接下来的-2019" class="headerlink" title="关于接下来的 2019"></a>关于接下来的 2019</h2><p><strong>项目</strong></p><p>当然是把 Here Music 写完，然后就是持续的维护。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">newChecklist.<span class="title function_">push</span>(<span class="string">&#x27;完成 Here Music 并持续维护&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>工作</strong></p><p>在完成 Here 音乐之后，就要开始复习准备春招，希望自己可以找到一个满意的工作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">newChecklist.<span class="title function_">push</span>(<span class="string">&#x27;找到满意的工作&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>英语</strong></p><p>的话，首先是继续坚持背单词，<strong>词汇量可以达到 7000</strong>。</p><p>单词之后是语法的学习，需要完成《新概念2》上 <strong>96课语法</strong> 学习。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">newChecklist.<span class="title function_">push</span>(<span class="string">&#x27;词汇量 7000&#x27;</span>, <span class="string">&#x27;《新概念2》&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>阅读</strong></p><p>至少读完 5 本技术书籍，加上 1 本英文原版书籍。</p><p>书籍：没坚持看完的《红宝书》、《你不知道的 JavaScript （中）》、《Node.js 实战》、《ES6 深入理解》、《JavaScript 设计模式与开发实践》</p><p>因为自己的基础还是很不扎实，所以还是需要继续巩固自己的基础。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">newChecklist.<span class="title function_">push</span>(<span class="string">&#x27;至少阅读 5 本技术书籍，1 本英文书籍&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>生活</strong></p><p>然后就是生活上的事情，希望 2019 自己可以好好赚钱，减少家人的压力。</p><p>然后和女友可以顺顺利利的步入社会。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">newChecklist.<span class="title function_">push</span>(<span class="string">&#x27;好好赚钱&#x27;</span>, <span class="string">&#x27;和女友顺顺利利步入社会 no bug no warning&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>毕业</strong></p><p>再怎么样，躲不了的还是大学毕业，怎么说呢，还是有些不舍吧。希望同学们都可以一起顺顺利利的毕业，找到顺心满意的工作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">newChecklist.<span class="title function_">push</span>(<span class="string">&#x27;顺利毕业&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，先看看我的 2018 年做了些什么吧。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oldChecklist);</span><br></pre></td></tr></table></figure><ol><li>入坑前端工程师</li><li>扫雷游戏</li><li>Vue 网易云音乐</li><li>书查查</li><li>快写完的 Here Music</li><li>实习三月</li><li>背了 2600 个单词</li></ol><p>那么我的 2019 又要做些什么呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newChecklist);</span><br></pre></td></tr></table></figure><ol><li>完成 Here Music 并维护</li><li>找到满意的工作</li><li>词汇量 7000</li><li>《新概念2》</li><li>至少阅读 5 本技术书籍，1 本英文书籍</li><li>好好赚钱</li><li>和女友顺顺利利步入社会 no bug no warning</li><li>顺利毕业</li></ol><p>2019，继续努力，每天都要开心！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于我的 2018 年度小结。</summary>
    
    
    
    
    <category term="生活" scheme="https://caijin.tech/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="总结" scheme="https://caijin.tech/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如何将打包好的静态网页部署至服务器</title>
    <link href="https://caijin.tech/2018/12/15/archived/2018-12-15-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E9%83%A8%E7%BD%B2%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://caijin.tech/2018/12/15/archived/2018-12-15-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E9%83%A8%E7%BD%B2%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2018-12-15T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>在完成书查查应用之后，需要将应用部署至服务器，记录一下部署的过。<span id="more"></span></p><h2 id="本地成功运行"><a href="#本地成功运行" class="headerlink" title="本地成功运行"></a>本地成功运行</h2><p>首先是运行 <code>npm run build</code> 打包应用，打包好的页面是无法直接访问的，具体原因在这里：<a href="https://cli.vuejs.org/zh/guide/deployment.html#%E9%80%9A%E7%94%A8%E6%8C%87%E5%8D%97">Vue-cli 部署</a>。</p><p>大概内容是：</p><blockquote><p><code>dist</code> 目录需要启动一个 HTTP 服务器来访问 (除非你已经将 <code>baseUrl</code> 配置为了一个相对的值)，所以以 <code>file://</code> 协议直接打开 <code>dist/index.html</code> 是不会工作的。在本地预览生产环境构建最简单的方式就是使用一个 Node.js 静态文件服务器。</p></blockquote><p>所以我需要使用 Node.js 起一个静态服务器，我这里用的是 Express，方法： <a href="http://www.expressjs.com.cn/starter/static-files.html">利用 Express 托管静态文件</a>。</p><p>只需要很简单的几行代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./dist&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3003</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Listening at http://localhost:&#x27;</span> + port + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后运行 <code>node filename.js</code> 服务就成功起来啦。这时候访问 <code>localhost:3003</code> 就可以访问部署好的静态页面。</p><p>下一步是上传代码到服务器。</p><h2 id="上传文件到服务器"><a href="#上传文件到服务器" class="headerlink" title="上传文件到服务器"></a>上传文件到服务器</h2><p>我使用的是 scp 命令上传文件到服务器上的，具体代码是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r ./dist root@120.79.162.***:/home/library-book-search/web/</span><br><span class="line"></span><br><span class="line">// 将 dist 文件夹 上传至 120.79... 的 /home/library-book/search/web/ 中</span><br></pre></td></tr></table></figure><ul><li>scp：上传命令</li><li>-r：上传文件是文件夹</li><li>./dist：本地需要上传文件的位置</li><li>root@120…：使用 root 用户名登录远程服务器 120….</li><li>:/home/library-book-search/web/：表示保存在远程服务器上的地址</li></ul><p>回车之后输入服务器密码，就可以等待文件上传成功了。</p><h2 id="在服务器上起服务"><a href="#在服务器上起服务" class="headerlink" title="在服务器上起服务"></a>在服务器上起服务</h2><p>首先进入到项目所在的文件夹，然后和在本地一样，运行 <code>node filename.js</code> 这样服务就成功跑起来了，然后访问发现并不 ok，捣鼓半天之后阿里云这个端口并不是默认开放的，所以需要在阿里云的控制台把这台服务器需要使用的端口打开。</p><p>成功开启端口之后终于访问成功了，于是美滋滋的关掉命令行，准备和朋友炫耀一番，结果打脸了，又访问失败了。再一顿思考之后发现，当关闭命令行界面之后，node 服务会自动关闭。所以我们的服务就扑街了。</p><p>这个时候就需要使用 <a href="http://pm2.keymetrics.io/">PM2</a> 来维护我的服务啦，在服务起上全局安装 PM2 之后，<code>pm2 start filename.js</code> ，项目就真正的完美啦。这下关掉命令行界面也不用担心任务爆炸了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在完成书查查应用之后，需要将应用部署至服务器，记录一下部署的过。</summary>
    
    
    
    
    <category term="后端" scheme="https://caijin.tech/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个因文件名称大小写产生的错误</title>
    <link href="https://caijin.tech/2018/11/24/archived/2018-11-24-%E4%B8%80%E4%B8%AA%E5%9B%A0%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%A4%A7%E5%B0%8F%E5%86%99%E4%BA%A7%E7%94%9F%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://caijin.tech/2018/11/24/archived/2018-11-24-%E4%B8%80%E4%B8%AA%E5%9B%A0%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0%E5%A4%A7%E5%B0%8F%E5%86%99%E4%BA%A7%E7%94%9F%E7%9A%84%E9%94%99%E8%AF%AF/</id>
    <published>2018-11-24T21:50:49.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>之前实习的时候在写完代码上线部署的时候发现服务器 Build 的时候找不到依赖文件，但是在本地 Build 却正常，检查了半天本地明明没有问题，但是服务器上就是报路径错误，让我很是头疼。 <span id="more"></span></p><p>最后在大佬帮助 Debug 后发现服务器上面有<strong>两个同名文件夹（大小写不同）</strong>。例如：<code>ABC</code> 和 <code>abc</code> 两个文件夹，因为服务器是 Linux 系统，<strong>而 Linux 系统是区分大小写的</strong>，所以两个文件可以同时存在，但是在拉到本地之后，就<strong>合并成了一个</strong>文件夹 <code>ABC</code> （因为 Windows 和 macOS（默认） 以及 Git（默认） 是不区分大小写的），这个时候 <code>abc</code> 文件夹在本地是看不见的，合并到了 <code>ABC</code> 文件夹中。</p><p>因为本地 <code>abc</code> 文件夹中的所有文件都在 <code>ABC</code> 文件夹中，所以代码中所有的依赖路径都是 <code>../ABC/..</code> ，这个时候在本地跑是没有问题的。</p><p><strong>但是在服务器上面，其实依赖的文件有一部分是存在 <code>abc</code> 中的。因为路径都是指向 <code>ABC</code> ，而 <code>ABC</code> 文件中并没有这些文件（文件在 <code>abc</code> 中），这个时候就会报路径错误。</strong></p><h2 id="这样的错误是如何产生的？"><a href="#这样的错误是如何产生的？" class="headerlink" title="这样的错误是如何产生的？"></a>这样的错误是如何产生的？</h2><p>发生这样的问题我也是很好奇，于是我翻到了这个文件夹当时的 commit 记录，发现当时是两个人一起来开发一个任务，于是大家一起商量好的文件夹的名称，却因为没有规范名称的大小写所以出现了问题。</p><p>例如 A 创建了 <code>ABC</code> 然后代码里的依赖路径为 <code>../ABC/..</code>，B 创建了 <code>abc</code>，依赖路径为 <code>../abc/..</code>。因为上传到服务端之后文件夹都是会存在的，并不会合并，所以对于当时的情况来说，并不会发生路径错误。so，这个坑就这样产生了。</p><h2 id="这个错误引发的问题"><a href="#这个错误引发的问题" class="headerlink" title="这个错误引发的问题"></a>这个错误引发的问题</h2><p><strong>这个坑对于以后的开发人员来说就说一个很大的坑了，不，应该说是巨坑、天坑！</strong></p><p><em>这一段可能会很绕，仔细看：</em>因为代码再 pull 到本地之后，两个文件夹就会合并成一个，比如这个时候合并成了 <code>ABC</code> ，那么这个时候依赖 <code>../abc/..</code> 的功能就爆炸了，这个时候 Debug 就发现，咦，这里怎么会有依赖 <code>../abc/..</code> 的路径，怪不得会有问题，赶紧改成 <code>../ABC/..</code>，嗯，这个时候代码 OK 了，可以跑起来了。<strong>但是！</strong>当代码再次 push 到了服务器上的时候，问题又来了，因为依赖 <code>abc</code> 文件夹的代码被改成了 <code>../ABC/..</code> 啊，但是文件其实还是在 <code>abc</code> 中的啊，所以服务器上的代码又爆炸了。</p><p>这个时候接手代码人的内心：wtf？？？让我死不好吗。</p><h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><p>把服务器上的两个文件夹先删掉一个，然后重新上传一下代码，确保只有一个文件夹。</p><h2 id="如何避免这样的问题："><a href="#如何避免这样的问题：" class="headerlink" title="如何避免这样的问题："></a><strong>如何避免这样的问题：</strong></h2><ol><li><strong>确定好文件名的规范，比如使用驼峰，或者全部小写等等</strong></li><li>两个分支同时创建文件夹的时候名字大小写不要搞错了，不然合并的时候就是两个文件夹</li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>Git 为什么是默认不区分大小写？</strong></p><p>其实根据上面的一些分析，我觉得有一定原因是为了兼容 Widnows 和 macOS 的，因为这两个系统默认是不区分大小写的。</p><p>即使 Git 支持了区分大小写，可以有两个大小写不同但是名称相同的文件夹，但是 Windows 和 macOS 不能显示，那岂不是很尴尬。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前实习的时候在写完代码上线部署的时候发现服务器 Build 的时候找不到依赖文件，但是在本地 Build 却正常，检查了半天本地明明没有问题，但是服务器上就是报路径错误，让我很是头疼。</summary>
    
    
    
    
    <category term="Git" scheme="https://caijin.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>七月实习小记</title>
    <link href="https://caijin.tech/2018/08/12/archived/2018-08-12-%E4%B8%83%E6%9C%88%E5%AE%9E%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <id>https://caijin.tech/2018/08/12/archived/2018-08-12-%E4%B8%83%E6%9C%88%E5%AE%9E%E4%B9%A0%E5%B0%8F%E8%AE%B0/</id>
    <published>2018-08-12T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>在写这篇小记的前，还是想感叹一下时间真的是过的飞快，从7月来杭州到现在已经实习了一个月了。所以用这篇文章记录一下实习的经历。</p><span id="more"></span><h2 id="6-x-找实习"><a href="#6-x-找实习" class="headerlink" title="6.x 找实习"></a>6.x 找实习</h2><p>好像是五月份的时候准备要实习的吧，那个时候已经错过了三四月的春招实习了。记得那个时候还在学习 Vue，在学习写 Vue 音乐APP 的项目，写完之后就开始准备简历了。emmm，算了。具体找实习的过程就不说啦（偷懒偷懒😂）~</p><h2 id="7-8-7-10-租房"><a href="#7-8-7-10-租房" class="headerlink" title="7.8 - 7.10 租房"></a>7.8 - 7.10 租房</h2><p>出来实习嘛，免不了的就是租房。租房经验什么的，直接去知乎看就好啦。我自己这次租房最大个感触的话：</p><ul><li>一定要离公司近，真的很爽的！</li><li>看房一定要白天去看，晚上去看很多东西都看不见的（发霉什么的😨）！</li><li>可以的话，一定要多看几家。</li><li>一定要有耐心，稳住自己。因为租房真的很烦躁~</li></ul><p>我这边是一开始在豆瓣上看好了然后商量好了看房时间，然后来杭州了之后直接去看房了。因为我是晚上去看的，然后感觉还行，但是幸好没有签下来。因为第二天白天去看发现有太多细节晚上看不见，然后就放弃了。</p><p>最后是在小区里面的公告栏上看的广告，房东直租，打电话还问我是不是中介emmm。大家租房也可以试一试，直接去小区个公告栏上看就好，房东直租挺好的，还不要中介费呢~</p><h2 id="7-11-8-11-实习"><a href="#7-11-8-11-实习" class="headerlink" title="7.11 - 8.11 实习"></a>7.11 - 8.11 实习</h2><p>因为自己从来没有在公司实习过，而且自己的专业也不是计算机专业，没有合作开发的经验。所以，实习中的工作对我来说是很有挑战性的，也是我在实习的过程中需要学习的。</p><p>入职之后首先是有一个入职测试，主要是帮助实习生来规范代码、体验 Git 和 GitLab 的使用。大家会对测试的代码进行 Review，然后给出一些代码上的建议。</p><h3 id="实习中的收获"><a href="#实习中的收获" class="headerlink" title="实习中的收获"></a>实习中的收获</h3><p>在开发上自己也是遇到了很多的问题，然后学习到了很多。</p><h4 id="代码规范："><a href="#代码规范：" class="headerlink" title="代码规范："></a>代码规范：</h4><p>在开发的过程中，因为是大家一起维护一个仓库，所以很有可能发生代码质量参差不齐的情况，这个时候就需要合适的代码规范来规范大家的代码。这样的话就可以减少开发中的维护成本。</p><p>我的问题：因为是刚刚入职，所以肯定是对公司业务代码以及代码规范不了解，所以就会写出代码肯定会有一些不足。</p><p>解决方法：严格遵守代码规范，使用 ESLint 规范代码，然后每次写完代码都要让 Mentor 来帮忙 Review 一下代码，及时找出代码中的问题。然后写出规范、易懂已维护的代码。</p><h4 id="业务代码庞大："><a href="#业务代码庞大：" class="headerlink" title="业务代码庞大："></a>业务代码庞大：</h4><p>在写代码的时候效率会很低，原因是业务中的代码会很庞大。所以很难定位到需要改动的地方。</p><p>解决办法：使用全局搜索的功能，根据关键词快速定位。</p><h4 id="Git-使用不熟练："><a href="#Git-使用不熟练：" class="headerlink" title="Git 使用不熟练："></a>Git 使用不熟练：</h4><p>在自己进行开发的时候是对于 Git 的操作仅仅停留在 pull, clone 上。来了公司之后才真正的感受都 Git 的强大！尤其是在多人协作开发的时候。但是也暴露出了自己对于 Git 使用的问题。</p><p>解决方法：多看文档，多学习。记住常用的操作，不会的就搜啦~</p><h4 id="上线流程："><a href="#上线流程：" class="headerlink" title="上线流程："></a>上线流程：</h4><p>公司对于功能的上线也是有着非常规范的流程，提测 - 上测试环境 - 测试 - alpha - beta - 外网。对于我这个从来没有测试概念的菜鸡来说，真的是很蒙圈的。但是好在目前已经基本了解了上线的流程。</p><p>解决方法：看组内的提测上线流程，然后多和前辈交流。</p><h4 id="提问的方法："><a href="#提问的方法：" class="headerlink" title="提问的方法："></a>提问的方法：</h4><p>当碰到一个问题的时候，首先应该是自己思考，然后再去谷歌百度，最后实在解决不出来的话，或者要花的时间太久，才应该带着自己的思考去问前辈们。而不是不会就去问，这样子不好。</p><h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><ol><li>自己的水平还是非常有限，所以需要技术上的进步。  </li><li>在工作的过程中应该随时记录和总结自己的收获和思考。  </li><li>工作中除了业务的开发，还需要留一点时间进行提升，而不是把所有的时间放在业务的开发上面。  </li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后最后说点什么呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在写这篇小记的前，还是想感叹一下时间真的是过的飞快，从7月来杭州到现在已经实习了一个月了。所以用这篇文章记录一下实习的经历。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://caijin.tech/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>JS 中数组的遍历</title>
    <link href="https://caijin.tech/2018/08/11/archived/2018-08-11-JS%20%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>https://caijin.tech/2018/08/11/archived/2018-08-11-JS%20%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2018-08-11T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下JS中遍历常用的一些方法。<span id="more"></span></p><h3 id="1-for-循环"><a href="#1-for-循环" class="headerlink" title="1.for 循环"></a>1.for 循环</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是一种常用的遍历方法，可以在 for 循环中使用 <code>break</code> 和 <code>continue</code> 方法来跳出。</p><h3 id="2-for…in-（对象也可以使用）"><a href="#2-for…in-（对象也可以使用）" class="headerlink" title="2. for…in （对象也可以使用）"></a>2. for…in （对象也可以使用）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i])</span><br><span class="line">    <span class="keyword">if</span> (arr[i] = <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p><code>for...in</code> 循环不仅可以遍历对象，也可以遍历数组。当 “对象” 为数组时，“变量” 指的是数组的 “索引”，当 “对象” 为对象是，“变量” 指的是对象的 “属性”。</p><p><strong>但是因为还会遍历非键值，以及原型属性所以尽量不要使用。</strong></p><h3 id="3-for…of"><a href="#3-for…of" class="headerlink" title="3. for…of"></a>3. for…of</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>与 for…in 不同的是，<strong>for…of 返回的直接是值</strong>。而 for…in 得到的是 key，<strong>且 for…of 无法遍历对象</strong>。</p><h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map()"></a>4. map()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line">num</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>map</code> 方法将数组的所有成员依次传入参数函数，<strong>然后把每一次的执行结果组成一个新数组返回</strong>。</p><p><code>map</code> 方法接受一个函数作为参数。该函数调用时，<code>map</code>方法向它传入三个参数：当前成员、当前位置和数组本身。<strong>该方法不会改变原数组。</strong></p><h3 id="5-forEach"><a href="#5-forEach" class="headerlink" title="5. forEach()"></a>5. forEach()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p> <code>forEach</code> 和 <code>map</code> 的区别是它只操作数据本身，<strong>并没有返回值</strong>。而 <code>map</code> 会返回一个新的数组~，但是相同点是它们的参数函数都可以传入三个参数。<strong>该方法不会改变原数组。</strong></p><h3 id="6-filter"><a href="#6-filter" class="headerlink" title="6. filter()"></a>6. filter()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">filter</span>(<span class="function">(<span class="params">elem</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (elem &gt; <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 5]</span></span><br></pre></td></tr></table></figure><p><code>filter</code> 方法用于过滤数组成员，<strong>满足条件的成员组成一个新数组返回</strong>。</p><p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。<strong>该方法不会改变原数组。</strong></p><h3 id="7-some"><a href="#7-some" class="headerlink" title="7. some()"></a>7. some()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line">arr.<span class="title function_">some</span>(<span class="function">(<span class="params">elem</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>some</code> 方法是用来判断数组的内容是否符合某种条件。接受的参数和 map, forEach 一样。</p><p><code>some</code> 方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。<strong>且只要有一个成员能返回 true，那么遍历就会停止！</strong></p><p>和 <code>some</code> 相似的还有 <code>every</code>。</p><h3 id="8-every"><a href="#8-every" class="headerlink" title="8. every()"></a>8. every()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">every</span>(<span class="function">(<span class="params">elem</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;didi:&#x27;</span>, elem)</span><br><span class="line">  <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">every</span>(<span class="function">(<span class="params">elem</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>every</code> 的区别是，当所有成员都返回 <code>true</code> 的时候，才会返回 <code>true</code>。<strong>且只要有一个成员能返回 false，那么遍历就会停止！</strong></p><p>参考：<a href="http://javascript.ruanyifeng.com/stdlib/array.html#toc13">阮一峰 JavaScript 标准参考指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结一下JS中遍历常用的一些方法。</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://caijin.tech/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 二叉搜索树</title>
    <link href="https://caijin.tech/2018/06/06/archived/2018-06-08-JS%E4%BA%8C%E6%90%9C%E7%B4%A2%E5%8F%89%E6%A0%91/"/>
    <id>https://caijin.tech/2018/06/06/archived/2018-06-08-JS%E4%BA%8C%E6%90%9C%E7%B4%A2%E5%8F%89%E6%A0%91/</id>
    <published>2018-06-06T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树（创建、遍历、搜索、插入等）、JavaScript 实现翻转二叉树了解一哈。</p><span id="more"></span><h2 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h2><p><strong>二叉树的定义：</strong> 二叉树的每个结点至多只有二棵子树（不存在度大于2的结点），二叉树的子树有左右之分，次序不能颠倒。</p><p><strong>二叉查找树（BST）：</strong> 又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉查找树是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。</p><h2 id="创建一个二叉查找树"><a href="#创建一个二叉查找树" class="headerlink" title="创建一个二叉查找树"></a>创建一个二叉查找树</h2><p>首先创建一个 <code>BinarySearchTree</code> 类。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了 ES6 的 Class 语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Node</span>(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      key,</span><br><span class="line">      left,</span><br><span class="line">      right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下二叉查找树的数据结构组织方式（没有找到二叉搜索树的先用二叉树的代替一下）：</p><img src="https://s2.ax1x.com/2019/01/01/F5KfhR.png" alt="F5KfhR.png" border="0"><p>二叉树是通过指针（指向下一个节点）来表示节点之间的关系的，所以需要在声明 Node 的时候，定义两个指针，一个指向左边，一个指向右边。 还需要声明一个 root 来保存树的根元素。</p><h2 id="向树中插入一个键（节点）"><a href="#向树中插入一个键（节点）" class="headerlink" title="向树中插入一个键（节点）"></a>向树中插入一个键（节点）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>  &#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  insert (key) &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="variable language_">this</span>.<span class="title class_">Node</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果根节点为空，那么插入的节点就为根节点</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果根节点不为空</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insertNode (node, newNode) &#123;</span><br><span class="line">    <span class="comment">// 当新节点比父节点小，插入左边</span></span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">key</span> &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// 左边没有内容则插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有内容就继续递归，直到没有内容然后可以插入</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 右边和左边相同，不重复说明</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用了 class 所以没有学过 class 的同学可以先看一下 ES6 的 class，再来看文章。</p><p>仔细分析上面的代码，多看几遍就可以了解其中的奥妙（也可以自己在游览器中运行一下，插入几个值试一下）。</p><p>运行一遍试一下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>()</span><br><span class="line">m.<span class="title function_">insert</span>(<span class="number">5</span>)</span><br><span class="line">m.<span class="title function_">insert</span>(<span class="number">4</span>)</span><br><span class="line">m.<span class="title function_">insert</span>(<span class="number">3</span>)</span><br><span class="line">m.<span class="title function_">insert</span>(<span class="number">6</span>)</span><br><span class="line">m.<span class="title function_">insert</span>(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>会得到这样的结构：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">left</span>: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">left</span>: &#123;</span><br><span class="line">      <span class="attr">key</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">right</span>: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">left</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">right</span>: &#123;</span><br><span class="line">      <span class="attr">key</span>: <span class="number">7</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm，真复杂（自己看的都头晕），还是画个图吧。</p><img src="https://s2.ax1x.com/2019/01/01/F5KRAJ.png" alt="F5KRAJ.png" border="0"><p>会生成这样一个二叉查找树~，插入功能就算完成啦！</p><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。访问树会有三种方法：中序、先序、后续。下面分别讲解</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是从最小到最大的顺序进行访问所有节点。具体方法，看代码吧，配上图多看两遍代码就能明白了（我是这么认为的）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>  &#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  inOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  inOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>, callback)</span><br><span class="line">      <span class="title function_">callback</span>(node.<span class="property">key</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，用图展示一下遍历的过程，具体过程看代码多思考一下。</p><img src="https://s2.ax1x.com/2019/01/01/F5K491.png" alt="F5K491.png" border="0"><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历会先访问节点本身，然后再访问它的左侧子节点，最后再访问右侧的节点。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>  &#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  preOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  preOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(node.<span class="property">key</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>, callback)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看代码，发现和中序遍历的区别不过是先执行了 <code>callback</code> 然后再遍历左右。</p><img src="https://s2.ax1x.com/2019/01/01/F5KWN9.png" alt="F5KWN9.png" border="0"><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历则是先访问节点的后代节点，然后再访问节点本身。实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>  &#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  postOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  postOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>, callback)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>, callback)</span><br><span class="line">      <span class="title function_">callback</span>(node.<span class="property">key</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再仔细看代码，发现和中序遍历的区别不过是先执行了遍历了左右，最后执行了 <code>callback</code> 。</p><p>惯例，画张图~</p><img src="https://s2.ax1x.com/2019/01/01/F5Kg74.png" alt="F5Kg74.png" border="0"><p>三种遍历方式讲完啦，不懂的可以多看几遍代码哦~</p><h2 id="搜索二叉搜索树中的值"><a href="#搜索二叉搜索树中的值" class="headerlink" title="搜索二叉搜索树中的值"></a>搜索二叉搜索树中的值</h2><p>在树中，通常有三种经常使用的搜索类型：</p><ul><li>搜索最大值</li><li>搜索最小值</li><li>搜索特定值</li></ul><p>下面一一列举</p><h3 id="搜索最小和最大值"><a href="#搜索最小和最大值" class="headerlink" title="搜索最小和最大值"></a>搜索最小和最大值</h3><p>首先我们知道二叉搜索树中的最小值在最左边，最大值在最右边。既然知道这个，那么实现搜索最大和最小就十分简单了。所以直接上代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>  &#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 搜索最小</span></span><br><span class="line">  min () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">minNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  minNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="comment">// 如果节点存在，而且左边不为 null</span></span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.<span class="property">left</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> node.<span class="property">key</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果树为空，则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 搜索最大</span></span><br><span class="line">  max () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">maxNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  maxNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.<span class="property">right</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.<span class="property">key</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索特定的值"><a href="#搜索特定的值" class="headerlink" title="搜索特定的值"></a>搜索特定的值</h3><p>基本上的思路和遍历节点差不多，具体看代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>  &#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  search (key) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  searchNode (node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 key 比节点的值小，那么搜索左边的子节点，下面的相反</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">left</span>, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">right</span>, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>翻转一个二叉树，直观上看，就是把二叉树的每一层左右顺序倒过来。 </p><p><strong>例如：</strong></p><p>Input:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><p>仔细看就是先把最底下的节点反转，然后上一个节点再翻转。例如：1 - 3 反转成 3 - 1，6 - 9 反转成 9 - 6，  然后再让 2 - 7 反转。当然反过来也一样，先反转 2 - 7 也是可以的。</p><p>所以具体的过程是：</p><ol><li>翻转根节点的左子树（递归调用当前函数）</li><li>翻转根节点的右子树（递归调用当前函数）</li><li>交换根节点的左子节点与右子节点</li></ol><p>最后看一下实现的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span>  &#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line"> </span><br><span class="line">  invertTree (node = <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">invertTree</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">invertTree</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">exchange</span>(node)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  exchange (node) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = node.<span class="property">left</span></span><br><span class="line">    node.<span class="property">left</span> = node.<span class="property">right</span></span><br><span class="line">    node.<span class="property">right</span> = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就简单实现啦，舒服舒服~</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>全部代码在这里~</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Node</span>(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      key,</span><br><span class="line">      left,</span><br><span class="line">      right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="variable language_">this</span>.<span class="title class_">Node</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果根节点为空，那么插入的节点就为根节点</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">node, newNode</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node)</span><br><span class="line">    <span class="keyword">if</span> (newNode.<span class="property">key</span> &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inOrderTraverse</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inOrderTraverseNode</span>(<span class="params">node, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>, callback)</span><br><span class="line">      <span class="title function_">callback</span>(node.<span class="property">key</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">preOrderTraverse</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">preOrderTraverseNode</span>(<span class="params">node, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(node.<span class="property">key</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>, callback)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">postOrderTraverse</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">postOrderTraverseNode</span>(<span class="params">node, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>, callback)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>, callback)</span><br><span class="line">      <span class="title function_">callback</span>(node.<span class="property">key</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索最小</span></span><br><span class="line">  <span class="title function_">min</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">minNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">minNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="comment">// 如果节点存在，而且左边不为 null</span></span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.<span class="property">left</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> node.<span class="property">key</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树为空，则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索最大</span></span><br><span class="line">  <span class="title function_">max</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">maxNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">maxNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.<span class="property">right</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> node.<span class="property">key</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">search</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(<span class="variable language_">this</span>.<span class="property">root</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">searchNode</span>(<span class="params">node, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;node-&#x27;</span>, node, <span class="string">&#x27;---&#x27;</span>, node === <span class="literal">null</span>, <span class="string">&#x27;-key-&#x27;</span>, key)</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 比节点的值小，那么搜索左边的子节点，下面的相反</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">left</span>, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchNode</span>(node.<span class="property">right</span>, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;didi&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  invertTree (node = <span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">invertTree</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">invertTree</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">exchange</span>(node)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  exchange (node) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = node.<span class="property">left</span></span><br><span class="line">    node.<span class="property">left</span> = node.<span class="property">right</span></span><br><span class="line">    node.<span class="property">right</span> = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章是自己的学习的一个记录，如果能够顺便帮助大家学习一下，那就再好不过了。</p><p>但是因为本人技术技术有限，所以文章难免会有疏漏，欢迎指出。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>书籍：《学习 JavaScript 数据结构与算法》</li><li><a href="https://blog.csdn.net/u014359097/article/details/50225293">[数据结构][Leetcode]翻转二叉树</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉搜索树（创建、遍历、搜索、插入等）、JavaScript 实现翻转二叉树了解一哈。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://caijin.tech/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="https://caijin.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS 事件委托</title>
    <link href="https://caijin.tech/2018/05/25/archived/2018-5-25-event-bind/"/>
    <id>https://caijin.tech/2018/05/25/archived/2018-5-25-event-bind/</id>
    <published>2018-05-25T00:00:00.000Z</published>
    <updated>2022-08-22T05:06:00.795Z</updated>
    
    <content type="html"><![CDATA[<p>面试被问到事件委托了，虽然很早之前就使用过事件委托，但是面试的时候居然没有能够讲清楚，再总结一下吧。</p><span id="more"></span><blockquote><p>第一次经历面试，真的很紧张，很多自己明明会的东西也说不清，实在是丢脸。面试估计已经凉凉 了，吸取一下教训吧，学习的时候一定要学习扎实了。</p></blockquote><h2 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h2><p>事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。</p><p>引用个的例子：</p><blockquote><p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</p></blockquote><p><strong>那么为什么需要事件委托：</strong></p><ul><li>优点1: 提高 JavaScript 性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。</li><li>优点2: 动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>传统写法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;item1&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;item2&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;item3&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  item1.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;hello item1&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  item2.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;hello item2&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  item3.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;hello item3&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>试想，如果需要绑定 100 个 <code>li</code> 元素，那么岂不是需要绑定 100 个事件（浪费内存）。</li><li>当添加一个 DOM 元素的时候，传统的写法还需要再绑定新添加的 DOM。</li></ul><p><strong>事件委托</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#list&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + event.<span class="property">target</span>.<span class="property">innerText</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>利用事件委托，只需要给父元素添加了事件，就可以给所有 <code>li</code> 绑定事件，而不必要给每个 <code>li</code> 分别添加事件。这样就非常节省内存了，也很方便。</p><p>同时实现了动态添加 DOM 的时候不需要再添加事件。例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#list&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + event.<span class="property">target</span>.<span class="property">innerText</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> newVal = <span class="string">`&lt;li id=&quot;item4&quot;&gt;item4&lt;/li&gt;`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ul.<span class="property">innerHTML</span> = ul.<span class="property">innerHTML</span> + newVal</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个时候点击新添加的 item4 会发现打印了 <code>hello item4</code> 说明 item4 绑定了事件，即事件委托可以为新添加的 DOM 元素动态的添加事件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试被问到事件委托了，虽然很早之前就使用过事件委托，但是面试的时候居然没有能够讲清楚，再总结一下吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://caijin.tech/tags/JavaScript/"/>
    
  </entry>
  
</feed>
